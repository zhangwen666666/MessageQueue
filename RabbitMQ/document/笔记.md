# 一. RabbitMQ简介

## 1.1 什么是RabbitMQ？

* RabbitMQ是一个广泛使用的消息服务器，采用Erlang语言编写，是一种开源的实现 AMQP（高级消息队列协议）的**消息中间件**；

* RabbitMQ最初起源于金融系统，它的性能及稳定性都非常出色；

* AMQP协议（http://www.amqp.org），即 Advanced Message Queuing Protocol，高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计；

* 官网：https://www.rabbitmq.com

  github地址：https://github.com/rabbitmq



## 1.2 消息中间件

* 简单来说，消息中间件（MQ=Message Queue）就是指保存数据的一个容器（服务器），可以用于两个系统之间的数据传递。

* 消息中间件一般有三个主要角色：生产者、消费者、消息代理(消息队列、消息服务器)；

  ![image-20250401143324331](F:\JavaCode\MessageQueue\RabbitMQ\document\image\image-20250401143324331.png)

  生产者发送消息到消息服务器，然后消费者从消息代理（消息队列）中获取数据并进行处理；

* 常用的消息中间件：

  * RabbitMQ
  * kafka（大数据领域）
  * RocketMQ（阿里巴巴开源）献给Apache组织
  * pulsar（最近一两年流行起来的）



## 1.3 MQ的使用场景

### 1.3.1 异步处理

用户下订单---向MQ 发消息--》积分系统，红包系统，手机短信系统接收消息

![img](F:\JavaCode\MessageQueue\RabbitMQ\document\image\wps2.jpg)

* 用户下单之后，系统可能会给用户加积分，发红包，发短信提醒等操作。这些操作共用时700ms，但实际上用户只关心是否下单成功，因此可以只执行一步，其他的几步发MQ消息，让其余的程序去执行。

* 同步是阻塞的（会造成等待），异步是非阻塞的（不会等待）；

* 大流量高并发请求、批量数据传递，就可以采用异步处理，提升系统吞吐量；

### 1.3.2 系统解耦

多个系统之间，不需要直接交互，通过消息进行业务流转；

![img](F:\JavaCode\MessageQueue\RabbitMQ\document\image\wps3.jpg)

以前可能A系统直接与B、C、D系统交互，现在则不需要了。

### 1.3.3 流量削峰

高负载请求/任务的缓冲处理；

![img](F:\JavaCode\MessageQueue\RabbitMQ\document\image\wps4.jpg)

例如双十一等，同一时间可能有非常多的流量直接访问数据库，此时使用MQ可以匀速的接收，接收一点处理一点。

### 1.3.4 日志处理

**主要是用kafka这个服务器**来做；

日志处理是指将消息队列用于在日志处理中，比如Kafka解决大量日志传输的问题；

loger.info(.....)

ELK 日志处理解决方案：

loger.error(.....) -->logstash收集消息--> 发送消息的kafka --> elastic search (es) -->Kibana ELK日志处理平台



# 二. RabbitMQ的安装与运行

## 2.1 运行环境搭建

RabbitMQ是使用Erlang语言开发的，所以要先下载安装Erlang

### 2.1.1 Erlang及RabbitMQ安装版本的选择

* ***下载时一定要注意版本兼容性***
* 版本兼容说明地址：https://www.rabbitmq.com/which-erlang.html

![image-20250401144938088](F:\JavaCode\MessageQueue\RabbitMQ\document\image\image-20250401144938088.png)

### 2.1.2 下载Erlang

* Erlang官网：https://www.erlang.org/

* Linux下载：

  ```
  wget https://github.com/erlang/otp/releases/download/OTP-25.1.1/otp_src_25.1.1.tar.gz
  ```

### 2.1.3 安装Erlang

* 安装erlang前先安装Linux依赖库

  ```
  yum -y install make gcc gcc-c++ kernel-devel m4 ncurses-devel openssl-devel
  ```

* 解压erlang压缩包文件

  ```
  tar -zxvf otp_src_25.1.1.tar.gz
  ```

* 配置

  ```
  cd otp_src_25.1.1
  ./configure
  ```

* 编译

  ```
  make
  ```

* 安装

  ```
  make install
  ```

  * 安装好了erlang后可以将解压的文件夹删除：

  ```
  rm -rf otp_src_25.1.1
  ```

* 验证erlang是否安装成功

  在命令行输入： erl 如果进入了编程命令行则表示安装成功，然后按ctrl + z 退出编程命令行；



### 2.1.4 下载RabbitMQ

从RabbitMQ官网https://www.rabbitmq.com找到下载链接

Linux：下载3.10.11

```
wget https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.10.11/rabbitmq-server-generic-unix-3.10.11.tar.xz
```

### 2.1.5 安装RabbitMQ

* 解压RabbitMQ的压缩包，即安装完成，无需再编译

  ```
  tar -xvf rabbitmq-server-generic-unix-3.10.11.tar.xz  -C  /usr/local/
  ```

  此时RabbitMQ就装好了



## 2.2 启动及停止RabbitMQ

### 2.2.1 启动RabbitMQ

* 切换到安装目录的sbin目录下: 

  ```
  ./rabbitmq-server  -detached
  ```

  -detached 将表示在后台启动运行rabbitmq；不加该参数表示前台启动；

* rabbitmq的运行日志存放在安装目录的var目录下；

  ```
  /usr/local/rabbitmq_server-3.10.11/var/log/rabbitmq
  ```

### 2.2.2 查看RabbitMQ的状态

* 切换到sbin目录下执行：

  ```
  ./rabbitmqctl -n rabbit status
  ```

  -n rabbit 是指定节点名称为rabbit，目前只有一个节点，节点名默认为rabbit

  此处-n rabbit 也可以省略

### 2.2.3 停止RabbitMQ

* 切换到sbin目录下执行：

  ```
  ./rabbitmqctl shutdown
  ```

### 2.3.4 配置path环境变量

* 修改配置文件

  ```
  vi /etc/profile
  ```

* 添加如下：

  ```
  RABBIT_HOME=/usr/local/rabbitmq_server-3.10.11
  PATH=$PATH:$RABBIT_HOME/sbin
  
  export RABBIT_HOME PATH
  ```

* 刷新环境变量

  ```
  source /etc/profile
  ```

  配置完环境变量之后就可以在任意位置启动RabbitMQ了





# 三. 管理命令与管理后台

**`./rabbitmqctl`  是一个管理命令，可以管理rabbitmq的很多操作**

**`./rabbitmqctl help`可以查看一下有哪些操作**

**查看具体子命令 可以使用 `./rabbitmqctl help 子命令名称`**



## 3.1 用户管理

用户管理包括增加用户，删除用户，查看用户列表，修改用户密码。

这些操作都是通过rabbitmqctl管理命令来实现完成。

查看帮助：`rabbitmqctl add_user --help`

1. 查看当前用户列表

   ```
   rabbitmqctl list_users
   ```

2. 新增一个用户

   ```
   语法：rabbitmqctl add_user Username Password
   示例：rabbitmqctl add_user zhangsan 123456
   ```

3. 设置用户角色

   ```
   rabbitmqctl set_user_tags User Tag
   示例：rabbitmqctl set_user_tags admin administrator
   ```

4. 设置用户权限

   ```
   rabbitmqctl set_permissions -p / admin ".*" ".*" ".*"
   ```

   说明：此操作是设置admin用户拥有操作虚拟主机/下的所有权限

5. 查看用户权限

   ```
   rabbitmqctl list_permissions
   ```

   

## 3.2 web 管理后台(插件)

Rabbitmq有一个web管理后台，这个管理后台是以插件的方式提供的，启动后台web管理功能，切换到sbin目录下执行：

```
# 查看rabbitmq 的插件列表
./rabbitmq-plugins list
#启用
./rabbitmq-plugins enable rabbitmq_management 
#禁用
./rabbitmq-plugins disable rabbitmq_management
```

### 3.2.1 防火墙设置

```
systemctl status firewalld --检查防火墙状态
systemctl stop firewalld --关闭防火墙，Linux重启之后会失效
systemctl disable firewalld --防火墙置为不可用，Linux重启后，防火墙服务不自动启动，依然是不可用
```

### 3.2.2 访问

```
http://192.168.131.131:15672 
用户名/密码为我们上面创建的admin/123456
注意上面改成你的虚拟主机的ip地址
```

备注：如果使用默认用户guest、密码guest登录，会提示User can only log in via localhost 

说明guest用户只能从localhost本机登录，所以不要使用该用户。

### 3.2.3 通过web页面新建虚拟主机

![image-20250401163938842](F:\JavaCode\MessageQueue\RabbitMQ\document\image\image-20250401163938842.png)

建完之后如下：

![image-20250401164046282](F:\JavaCode\MessageQueue\RabbitMQ\document\image\image-20250401164046282.png)





# 四. 工作模型与交换机

## 4.1 模型简介

![image-20250401164428888](F:\JavaCode\MessageQueue\RabbitMQ\document\image\image-20250401164428888.png)

消息队列有三个核心要素： **消息生产者、消息队列、消息消费者；**

* 生产者（Producer）：发送消息的应用；（java程序，也可能是别的语言写的程序）
* 消费者（Consumer）：接收消息的应用；（java程序，也可能是别的语言写的程序）
* 连接（Connection）：连接RabbitMQ服务器的TCP长连接；
* 信道（Channel）：连接中的一个虚拟通道，消息队列发送或者接收消息时，都是通过信道进行的；

* 虚拟主机（Virtual host）：一个虚拟分组，在代码中就是一个字符串，当多个不同的用户使用同一个RabbitMQ服务时，可以划分出多个Virtual host，每个用户在自己的Virtual host创建exchange/queue等；（分类比较清晰、相互隔离）
* 交换机（Exchange）：交换机负责从生产者接收消息，并根据交换机类型分发到对应的消息队列中，起到一个路由的作用；
* 路由键（Routing Key）：交换机根据路由键来决定消息分发到哪个队列，路由键是消息的目的地址；
* 绑定（Binding）：绑定是队列和交换机的一个关联连接（关联关系）；
* 队列（Queue）：存储消息的缓存；
* 消息（Message）：由生产者通过RabbitMQ发送给消费者的信息；（消息可以任何数据，字符串、user对象，json串等等）



## 4.2 交换机

Exchange（X） 可翻译成交换机/交换器/路由器

### 4.2.1 交换机类型

1. Fanout Exchange 扇形交换机
2. Direct Exchange 直连交换机
3. Topic Exchange 主题交换机
4. Headers Exchange 头部交换机

### 4.2.2 Fanout Exchange

#### 介绍

* Fanout 扇形的，散开的； 扇形交换机

* 投递到所有绑定的队列，不需要路由键，不需要进行路由键的匹配，相当于广播、群发；（只要消息队列和交换机绑定了，就会发给该消息队列）

  ![img](F:\JavaCode\MessageQueue\RabbitMQ\document\image\wps1.jpg)

#### 示例

**<font size="4px">发送消息到消息队列</font>**

* 添加依赖

  ```xml
  <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-amqp</artifactId>
  </dependency>
  ```

* 配置信息

  ```yml
  spring:
    rabbitmq:
      host: 111.119.211.126
      port: 5672 # 5672是rabbitmq默认端口  15672是管理后台的端口
      username: admin
      password: ****** # 密码
      virtual-host: zw # 虚拟主机
  ```

* 配置类RabbitConfig

  ```java
  @Configuration
  public class RabbitConfig {
      // 1.定义交换机
      @Bean
      public FanoutExchange fanoutExchange(){
          return new FanoutExchange("exchange.fanout");
      }
  
      // 2.定义队列
      @Bean
      public Queue queueA(){
          // 注意这里的Queue是org.springframework.amqp.core.Queue
          return new Queue("queue.fanout.a");
      }
      @Bean
      public Queue queueB(){
          // 注意这里的Queue是org.springframework.amqp.core.Queue
          return new Queue("queue.fanout.b");
      }
  
      // 3.绑定交换机和队列
      @Bean
      public Binding bindingA(FanoutExchange fanoutExchange, Queue queueA){
          // 绑定队列A到交换机
          return BindingBuilder.bind(queueA).to(fanoutExchange);
      }
      @Bean
      public Binding bindingB(FanoutExchange fanoutExchange, Queue queueB){
          // 绑定队列A到交换机
          return BindingBuilder.bind(queueB).to(fanoutExchange);
      }
  }
  ```

* 发送消息的Service类

  ```java
  @Component
  @Slf4j
  public class MessageService {
      @Autowired
      private RabbitTemplate rabbitTemplate;
  
      public void sendMessage(){
          // 定义要发送的消息
          String msg = "helloworld";
          Message message = new Message(msg.getBytes());
          // 发送消息
          // 参数1：交换机名称，
          // 参数2：路由key， (扇形交换机不需要路由key，它将消息广播给与它相连的所有消息队列)
          // 参数3：消息
          rabbitTemplate.convertAndSend("exchange.fanout", "", message);
          log.info("发送消息完毕，发送时间：{}", new Date());
      }
  }
  ```

* 主启动类

  ```java
  @SpringBootApplication
  // 实现ApplicationRunner接口，在项目启动后，执行run方法
  public class Application implements ApplicationRunner {
  
      @Autowired
      private MessageService messageService;
  
      public static void main(String[] args) {
          SpringApplication.run(Application.class, args);
      }
  
      /**
       * 启动任务，程序一启动就会执行
       * @param args
       * @throws Exception
       */
      @Override
      public void run(ApplicationArguments args) throws Exception {
          // 发送消息，消息先到扇形交换机exchange.fanout
          // 然后转发给与它相连的所有消息队列queue.fanout.a和queue.fanout.b
          messageService.sendMessage();
      }
  }
  ```

**<font size="4px">从消息队列接收消息</font>**

* 添加依赖

  ```xml
  <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-amqp</artifactId>
  </dependency>
  ```

* 配置文件

  ```yml
  spring:
    rabbitmq:
      host: 111.119.211.126
      port: 5672 # 5672是rabbitmq默认端口  15672是管理后台的端口
      username: admin
      password: 123456
      virtual-host: zw # 虚拟主机
  ```

* 接收消息类

  ```java
  @Component
  @Slf4j
  public class ReceiveMessage {
      // 接收两个队列的消息
      @RabbitListener(queues={"queue.fanout.a","queue.fanout.b"})
      public void receiveMessage(Message message){
          byte[] body = message.getBody();// 消息体
          String msg = new String(body);
          log.info("接收到消息：{}", msg);
      }
  }
  ```

### 4.2.3 Direct Exchange

#### 介绍

直连交换机

根据路由键精确匹配（一模一样，区分大小写）进行路由消息队列；

例如以下结构：一个生产者，一个交换机，两个消息队列，两个消费者

* 如果路由key为Hello，则不会进入队列
* 如果路由key为error，会进入两个队列
* 如果路由key为info，只会进入第二个队列

![img](F:\JavaCode\MessageQueue\RabbitMQ\document\image\wps2-1743571452683-4.jpg)

#### 示例

**<font size="4px">发送消息到消息队列</font>**

* 引入依赖

* 配置文件 

  ```yml
  server:
    port: 8080
  
  spring:
    application:
      name: direct-exchange
  
    rabbitmq:
      host: 111.119.211.126
      port: 5672
      username: admin
      password: ******
      virtual-host: zw
  
  my:
    exchangeName: exchange.direct
    queueAName: queue.direct.a
    queueBName: queue.direct.b
  ```

* 配置类，配置交换机和消息队列

  ```java
  @Configuration
  @ConfigurationProperties(prefix = "my")
  public class RabbitConfig {
      private String exchangeName;
      private String queueAName;
      private String queueBName;
  
      // 创建交换机
      @Bean
      public DirectExchange directExchange() {
          return ExchangeBuilder.directExchange(exchangeName).build();
      }
  
      // 创建消息队列
      @Bean
      public Queue queueA() {
          return QueueBuilder.durable(queueAName).build();
      }
      @Bean
      public Queue queueB(){
          return QueueBuilder.durable(queueBName).build();
      }
  
      // 绑定交换机和队列
      @Bean
      public Binding bindingA(DirectExchange directExchange, Queue queueA) {
          // 将queueA绑定到directExchange交换机，并指定路由键为error
          return BindingBuilder.bind(queueA).to(directExchange).with("error");
      }
      @Bean
      public Binding bindingB1(DirectExchange directExchange, Queue queueB) {
          return BindingBuilder.bind(queueB).to(directExchange).with("error");
      }
  
      @Bean
      public Binding bindingB2(DirectExchange directExchange, Queue queueB) {
          return BindingBuilder.bind(queueB).to(directExchange).with("info");
      }
  
      @Bean
      public Binding bindingB3(DirectExchange directExchange, Queue queueB) {
          return BindingBuilder.bind(queueB).to(directExchange).with("warning");
      }
  }
  ```

* 发送消息

  ```java
  @Service
  @Slf4j
  public class MessageService {
      @Autowired
      private RabbitTemplate rabbitTemplate;
  
      public void sendMessage() {
          // 创建消息
          Message message = MessageBuilder.withBody("你好世界".getBytes()).build();
          // 往交换机exchange.direct上发消息，路由key是hello
          // 参数1：交换机名称，
          // 参数2：路由key，
          // 参数3：消息
          // 这里消息的路由key是hello与消息队列的都不匹配，因此消息会被交换机直接丢弃
  //        rabbitTemplate.convertAndSend("exchange.direct", "hello", message);
          rabbitTemplate.convertAndSend("exchange.direct", "info", message);
          log.info("发送消息完毕，发送时间：{}", new Date());
      }
  }
  ```

* 主启动类

  ```java
  @SpringBootApplication
  public class DirectApplication implements ApplicationRunner {
  
      @Autowired
      private MessageService messageService;
  
      public static void main(String[] args) {
          SpringApplication.run(DirectApplication.class, args);
      }
  
      @Override
      public void run(ApplicationArguments args) throws Exception {
          messageService.sendMessage(); // 发送消息
      }
  }
  ```

  **<font size=4px>接收消息</font>**

  ```java
  @Component
  @Slf4j
  public class ReceiveMessage {
  	// 发送消息的路由key为"info",因此只有队列queue.direct.b能接收到消息
      @RabbitListener(queues={"queue.direct.b"})
      public void receiveMessage(Message message){
          byte[] body = message.getBody();// 消息体
          String msg = new String(body);
          log.info("接收到消息：{}", msg);
      }
  }
  ```

### 4.3.4 Topic Exchange

#### 介绍

* Topic Exchange 主题交换机

* 通配符匹配，相当于模糊匹配；

  * `#`匹配多个单词，用来表示任意数量（零个或多个）单词
  * `*`匹配一个单词（必须有一个，而且只有一个），用.隔开的为一个单词：

  ```
  beijing.# == beijing.queue.abc, beijing.queue.xyz.xxx
  beijing.* == beijing.queue, beijing.xyz
  ```

  ![img](F:\JavaCode\MessageQueue\RabbitMQ\document\image\wps3-1743576067943-6.jpg)

#### 示例

**<font size=4px>发送消息</font>**

发送时指定的路由键：lazy.orange.rabbit

注意虽然这个key与Q2的两个都匹配，但进入队列的只有一条消息

* 配置类

  ```java
  @Configuration
  @Data
  @ConfigurationProperties(prefix = "my")
  public class RabbitConfig {
      private String exchangeName;
      private String queueAName;
      private String queueBName;
  
      // 创建交换机
      @Bean
      public TopicExchange topicExchange(){
          return ExchangeBuilder.topicExchange(exchangeName).build();
      }
  
      // 创建消息队列
      @Bean
      public Queue queueA(){
          // durable:开启持久化
          return QueueBuilder.durable(queueAName).build();
      }
      @Bean
      public Queue queueB(){
          return QueueBuilder.durable(queueBName).build();
      }
  
      // 绑定队列到交换机
      @Bean
      public Binding bindingA(TopicExchange topicExchange, Queue queueA){
          return BindingBuilder.bind(queueA).to(topicExchange).with("*.orange.*");
      }
      @Bean
      public Binding bindingB1(TopicExchange topicExchange, Queue queueB){
          return BindingBuilder.bind(queueB).to(topicExchange).with("*.*.rabbit");
      }
      @Bean
      public Binding bindingB2(TopicExchange topicExchange, Queue queueB){
          return BindingBuilder.bind(queueB).to(topicExchange).with("laze.#");
      }
  }
  ```

* 发送消息服务类

  ```java
  @Service
  public class MessageService {
      @Autowired
      private AmqpTemplate amqpTemplate; // amqp是协议，RabbitTemplate是amqp的实现
  
      public void sendMessage(){
          Message message = MessageBuilder.withBody("法外狂徒张三".getBytes()).build();
          amqpTemplate.convertAndSend("exchange.topic", "hello.world", message);
      }
  }
  ```

* 启动类

  ```java
  SpringBootApplication
  public class TopicApplication implements ApplicationRunner {
  
      @Autowired
      private MessageService messageService;
  
      public static void main(String[] args) {
          SpringApplication.run(TopicApplication.class, args);
      }
  
      @Override
      public void run(ApplicationArguments args) throws Exception {
          messageService.sendMessage();// 发送消息到主题交换机
      }
  }
  ```

### 4.3.5 Headers Exchange

#### 介绍

* Headers Exchange：头部交换机 （使用较少）
* 发消息时除了消息体，还可以包括消息头部
* **头部交换机与路由没有关系，不是通过路由来匹配的**

![img](F:\JavaCode\MessageQueue\RabbitMQ\document\image\wps4-1743580692274-8.jpg)

#### 示例

**<font size=4px>发送消息</font>**

* 配置类

  ```java
  @Configuration
  @Data
  @ConfigurationProperties(prefix = "my")
  public class RabbitConfig {
      private String exchangeName;
      private String queueAName;
      private String queueBName;
  
      // 创建交换机
      @Bean
      public HeadersExchange headersExchange(){
          return ExchangeBuilder.headersExchange(exchangeName).build();
      }
  
      // 创建消息队列
      @Bean
      public Queue queueA(){
          return QueueBuilder.durable(queueAName).build();
      }
      @Bean
      public Queue queueB(){
          return QueueBuilder.durable(queueBName).build();
      }
  
      // 绑定队列到交换机
      @Bean
      public Binding bindingA(HeadersExchange headersExchange, Queue queueA){
          Map<String, Object> headersValue = new HashMap<>();
          headersValue.put("type", "m");
          headersValue.put("status", "1");
          return BindingBuilder.bind(queueA).to(headersExchange).whereAll(headersValue).match();
      }
      @Bean
      public Binding bindingB1(HeadersExchange headersExchange, Queue queueB){
          Map<String, Object> headersValue = new HashMap<>();
          headersValue.put("type", "s");
          headersValue.put("status", "0");
          return BindingBuilder.bind(queueB).to(headersExchange).whereAll(headersValue).match();
      }
  }
  ```

* 发送消息的服务类

  ```java
  @Service
  @Slf4j
  public class MessageService {
      @Autowired
      private RabbitTemplate rabbitTemplate;
  
      public void sendMessage(){
          // 创建消息属性对象
          MessageProperties messageProperties = new MessageProperties();
          Map<String, Object> headersValue = new HashMap<>();
          // 发送到B队列
          headersValue.put("type", "s");
          headersValue.put("status", "0");
          messageProperties.setHeaders(headersValue); // 设置消息头
  
          // 消息
          Message message = MessageBuilder.withBody("头部交换机".getBytes()).
                  andProperties(messageProperties).build();
  
          rabbitTemplate.convertAndSend("exchange.headers", "", message);
          log.info("发送消息完毕，发送时间：{}", new Date());
      }
  }
  ```







# 五. 过期消息与死信

## 5.1 简介

过期消息也叫TTL消息，TTL：Time To Live 

消息的过期时间有两种设置方式：（过期消息）



## 5.2 设置消息的过期时间

### 5.2.1 设置单条消息的过期时间 

采用直连交换机，过期时间在消息属性中设置

```java
@Service
@Slf4j
public class MessageService {
    @Autowired
    private RabbitTemplate rabbitTemplate;

    public void sendMessage() {
        // 创建消息属性
        MessageProperties messageProperties = new MessageProperties();
        messageProperties.setExpiration("35000"); // 单位毫秒
        // 创建消息
        Message message = MessageBuilder.withBody("消息过期时间".getBytes())
                .andProperties(messageProperties).build();
        // 发送消息
        rabbitTemplate.convertAndSend("exchange.ttl.a", "info", message);
        log.info("发送消息完毕，发送时间：{}", new Date());
    }
}
// 单条消息的过期时间决定了在没有任何消费者消费时，消息可以存活多久；
```

![image-20250402175124004](F:\JavaCode\MessageQueue\RabbitMQ\document\image\image-20250402175124004.png)

如果消息在过期时间之内被接收了，消息就不会过期，之后给服务器一个响应，告诉服务器可以删除该消息了。虽然最后这条消息还是被删了，但不是因为过期被删除的。

### 5.2.2 通过队列属性设置消息过期时间

创建消息队列时设置队列的过期时间

```java
// 创建消息队列
@Bean
public Queue queue(){
    Map<String, Object> arguments = new HashMap<>();
    arguments.put("x-message-ttl", 30000); // 设置队列的过期时间

    // 方式一：使用 new Queue 的方式
    // Queue(String name, boolean durable, boolean exclusive, boolean autoDelete, Map arguments)
    // name: 队列名称
    // durable: 是否持久化
    // exclusive: 是否是排他队列
    // autoDelete: 是否自动删除
    // arguments: 其他参数
    // return new Queue(queueName, true, false, false, null);

    // 方式二：建造者模式
    return QueueBuilder.durable(queueName)
            .withArguments(arguments)
            .build();
}
// 队列的过期时间决定了在没有任何消费者的情况下，队列中的消息可以存活多久；
```

**注意事项：如果消息和对列都设置过期时间，则消息的TTL以两者之间较小的那个数值为准。**



## 5.3 死信队列

### 5.3.1 介绍

* 死信：过期的消息就被称为死信，

* 死信交换机：Dead-Letter-Exchange (DLX) 。这是**一个普通的交换机**，它可以是任何类型的交换机（direct、topic、headers、fanout等）。**当一条消息由于某些原因未能成功被消费（如消息过期、队列长度限制导致消息被拒绝等），这条消息可以被重新发送到一个指定的死信交换机。**通过配置原始队列的参数，可以指定如果消息成为“死信”时应该发送到哪个死信交换机。

* 死信队列：这是**绑定到死信交换机上的一个普通队列**。一旦消息被标记为死信，并且被发送到死信交换机后，根据绑定规则（binding keys等），这些**消息会被路由到对应的死信队列**中。开发者可以通过监听死信队列来处理这些未能成功处理的消息，比如进行日志记录、错误分析或者尝试重新处理等操作。

  ![image-20250402213816596](F:\JavaCode\MessageQueue\RabbitMQ\document\image\image-20250402213816596.png)

* 以下情况下消息会进入死信队列：
  * 消息过期
  * 队列过期
  * 队列达到最大长度（先入队的消息会被发送到DLX）
  * 消费者拒绝消息不进行重新投递
  * 消费者拒绝消息



### 5.3.2 队列过期

**<font size=4>案例</font>**

利用死信交换机来实现订单超时功能，假设用户下单之后会向交换机发送一条消息，经过路由key（这里设置为`order`）到达消息队列。这个消息队列没有任何消费者，我们设置队列的过期时间为35秒，20秒过后就会进入到死信交换机中，然后经过路由到达死信队列，死信队列的消费者拿到这条消息之后，就可以去数据库比对该订单是否支付了，如果支付了，则什么也不用做。如果没支付，就关闭交易，关闭交易之后就不能支付了。

![image-20250402214718441](F:\JavaCode\MessageQueue\RabbitMQ\document\image\image-20250402214718441.png)

**<font size=4>重点: 为正常的消息队列设置死信交换机，并设置其路由key，保证进入死信交换机的消息能顺利到达死信队列</font>**

**<font size=4>代码</font>**

* 配置文件：

  ```yml
  server:
    port: 8080
  
  spring:
    application:
      name: dlx-learn1
  
    rabbitmq:
      host: 111.119.211.126
      port: 5672
      username: admin
      password: *******
      virtual-host: zw
  
  my:
    exchangeNormalName: exchange.normal.a # 正常交换机名称
    queueNormalName: queue.normal.a # 正常队列名称
    exchangeDlxName: exchange.dlx.a # 死信交换机名称
    queueDlxName: queue.dlx.a # 死信队列名称
  ```

* 配置类。配置消息队列与交换机

  ```java
  @Configuration
  @ConfigurationProperties("my")
  @Data
  public class RabbitConfig {
      private String exchangeNormalName; // 正常交换机名称
      private String queueNormalName; // 正常队列名称
      private String exchangeDlxName; // 死信交换机名称
      private String queueDlxName; // 死信队列名称
  
      // 创建正常交换机
      @Bean
      public DirectExchange normalExchange() {
          return new DirectExchange(exchangeNormalName);
      }
      // 创建正常队列
      @Bean
      public Queue normalQueue(){
          // 设置队列的属性
          Map<String, Object> arguments = new HashMap<>();
          arguments.put("x-message-ttl", 35000); // 设置队列的过期时间
          arguments.put("x-dead-letter-exchange", exchangeDlxName); // 设置队列的死信交换机
          arguments.put("x-dead-letter-routing-key", "error"); // 设置队列的死信路由key
          return new Queue(queueNormalName, true, false, false, arguments);
      }
      // 绑定正常交换机和正常队列
      @Bean
      public Binding bindingNormal(DirectExchange normalExchange, Queue normalQueue) {
          return BindingBuilder.bind(normalQueue).to(normalExchange).with("order");
      }
  
      // 创建死信交换机
      @Bean
      public DirectExchange dlxExchange() {
          return ExchangeBuilder.directExchange(exchangeDlxName).build();
      }
      // 创建死信队列
      @Bean
      public Queue dlxQueue(){
          return QueueBuilder.durable(queueDlxName).build();
      }
      // 绑定死信交换机和死信队列
      @Bean
      public Binding bindingDlx(DirectExchange dlxExchange, Queue dlxQueue){
          return BindingBuilder.bind(dlxQueue).to(dlxExchange).with("error");
      }
  }
  ```

* 发送消息的服务类

  ```java
  @Service
  @Slf4j
  public class MessageService {
      @Autowired
      private RabbitTemplate rabbitTemplate;
  
      public void sendMsg(){
          Message message = MessageBuilder.withBody("订单1".getBytes()).build();
          // 发送消息
          rabbitTemplate.convertAndSend("exchange.normal.a", "order", message);
          log.info("发送消息完毕，发送时间：{}", new Date());
      }
  }
  ```

* 启动类

  ```java
  @SpringBootApplication
  public class Dlx1Application implements ApplicationRunner {
  
      @Autowired
      private MessageService messageService;
  
      public static void main(String[] args) {
          SpringApplication.run(Dlx1Application.class, args);
      }
  
      @Override
      public void run(ApplicationArguments args) throws Exception {
          messageService.sendMsg();
      }
  }
  ```



### 5.3.3 消息过期

**<font size=4>代码</font>**

* 配置文件

  ```yml
  server:
    port: 8080
  
  spring:
    application:
      name: dlx-learn2
  
    rabbitmq:
      host: 111.119.211.126
      port: 5672
      username: admin
      password: ****
      virtual-host: zw
  
  my:
    exchangeNormalName: exchange.normal.2 # 正常交换机名称
    queueNormalName: queue.normal.2 # 正常队列名称
    exchangeDlxName: exchange.dlx.2 # 死信交换机名称
    queueDlxName: queue.dlx.2 # 死信队列名称
  ```

* 配置类，配置交换机和消息队列

  ```java
  @Configuration
  @ConfigurationProperties("my")
  @Data
  public class RabbitConfig {
      private String exchangeNormalName; // 正常交换机名称
      private String queueNormalName; // 正常队列名称
      private String exchangeDlxName; // 死信交换机名称
      private String queueDlxName; // 死信队列名称
  
      // 创建正常交换机
      @Bean
      public DirectExchange normalExchange() {
          return new DirectExchange(exchangeNormalName);
      }
      // 创建正常队列
      @Bean
      public Queue normalQueue(){
          // 也可以采用建造者模式来绑定死信交换机和死信路由key
          return QueueBuilder.durable(queueNormalName)
                  .deadLetterExchange(exchangeDlxName) // 绑定死信交换机
                  .deadLetterRoutingKey("error") // 绑定死信路由key
                  .build();
      }
      // 绑定正常交换机和正常队列
      @Bean
      public Binding bindingNormal(DirectExchange normalExchange, Queue normalQueue) {
          return BindingBuilder.bind(normalQueue).to(normalExchange).with("order");
      }
  
      // 创建死信交换机
      @Bean
      public DirectExchange dlxExchange() {
          return ExchangeBuilder.directExchange(exchangeDlxName).build();
      }
      // 创建死信队列
      @Bean
      public Queue dlxQueue(){
          return QueueBuilder.durable(queueDlxName).build();
      }
      // 绑定死信交换机和死信队列
      @Bean
      public Binding bindingDlx(DirectExchange dlxExchange, Queue dlxQueue){
          return BindingBuilder.bind(dlxQueue).to(dlxExchange).with("error");
      }
  }
  ```

* 发送消息的Service类。在这里设置消息的过期时间

  ```java
  @Service
  @Slf4j
  public class MessageService {
      @Autowired
      private RabbitTemplate rabbitTemplate;
  
      public void sendMsg(){
          // 消息属性
          MessageProperties messageProperties = new MessageProperties();
          messageProperties.setExpiration("30000"); // 设置过期时间，单位为毫秒
          // 创建消息
          Message message = MessageBuilder.withBody("订单2".getBytes()).andProperties(messageProperties).build();
          // 发送消息
          rabbitTemplate.convertAndSend("exchange.normal.2", "order", message);
          log.info("发送消息完毕，发送时间：{}", new Date());
      }
  }
  ```




### 5.3.4 队列达到最大长度

队列达到最大长度之后，先入队的消息会被发送到死信交换机。

在创建正常的消息队列时为其设置最大长度属性

```java
// 设置队列的最大长度

// 方法一：
// 设置队列的属性
Map<String, Object> arguments = new HashMap<>();
//设置队列的最大长度 ，对头的消息会被挤出变成死信
arguments.put("x-max-length", 5);
arguments.put("x-dead-letter-exchange", exchangeDlxName); // 设置队列的死信交换机
arguments.put("x-dead-letter-routing-key", "error"); // 设置队列的死信路由key
// return new Queue(queueNormalName, true, false, false, arguments);
return QueueBuilder.durable(queueNormalName).withArguments(arguments).build();

// 方法二：建造者模式
return QueueBuilder.durable(queueNormalName)
        .maxLength(5)
        .deadLetterExchange(exchangeDlxName) // 绑定死信交换机
        .deadLetterRoutingKey("error") // 绑定死信路由key
        .build();
```



### 5.3.5 消费者拒绝消息不进行重新投递

之前我们的模型中，生产的消息没有消费者。现在我们给其添加消费者。从正常的队列接收消息，但是对消息不进行确认，并且不对消息进行重新投递，此时消息就进入死信队列。

![image-20250407104818073](F:\JavaCode\MessageQueue\RabbitMQ\document\image\image-20250407104818073.png)

* 配置文件：开启手动确认

  ```yml
  # 在消费者端进行配置
  spring:
    rabbitmq:
      listener:
        type: direct
        direct:
          acknowledge-mode: manual
  
  # 注意如果不指定type，要将direct改成simple，手动确认才会生效
  spring:
    rabbitmq:
      listener:
        simple:
          acknowledge-mode: manual
  ```

* 接收端：

  ```java
  @Component
  @Slf4j
  public class MessageReceive {
      /**
       * 接收消息
       * @param message 消息
       * @param channel 信道 所有的消息接收和发送都通过信道
       */
      @RabbitListener(queues = {"queue.normal.4"})
      public void receive(Message message, Channel channel) {
          // 获取消息属性
          MessageProperties messageProperties = message.getMessageProperties();
          // 获取消息的唯一标识
          long deliveryTag = messageProperties.getDeliveryTag();
          try{
              // 接收消息并做后序处理，例如更新数据库
              String msg = new String(message.getBody());
              log.info("接收到消息：{}, 接收时间为{}", msg, new Date());
              // 处理成功，确认消息
              channel.basicAck(deliveryTag, false);
          } catch (Exception e){
              log.error("接收者出现问题，原因是{}", e.getMessage());
              try {
                  // 不确认并重新入队
                  // channel.basicNack(deliveryTag, false, true);
                  
                  // 拒绝消息并且不重新入队
                  channel.basicReject(deliveryTag, false);
              } catch (IOException ex) {
                  ex.printStackTrace();
              }
          }
      }
  }
  ```

  * 两个方法原型

    ```java
    // deliveryTag：消息的一个数字标签，唯一标识
    // multiple如果是true表示对小于deliveryTag标签下的消息都进行确认，false表示只确认当前的一条消息
    void basicAck(long deliveryTag, boolean multiple);
    
    // deliveryTag：消息的一个数字标签，唯一标识
    // multiple: true表示对小于deliveryTag标签下的消息都进行不确认，false表示只不确认当前的一条消息
    // requeue: true表示重新放入队列中，理论上可以被再次消费，false表示被丢弃或发送到死信交换机中
    void basicNack(long deliveryTag, boolean multiple, boolean requeue);
    
    // deliveryTag：消息的一个数字标签，唯一标识
    // requeue: 是否重新入队
    void basicReject(long deliveryTag, boolean requeue);
    ```





# 六. 延迟队列

场景：有一个订单，15分钟内如果不支付，就把该订单设置为交易关闭，那么就不能支付了，这类实现延迟任务的场景就可以采用延迟队列来实现，当然除了延迟队列来实现，也可以有一些其他办法实现；

## 6.1 定时任务方式

每隔3秒扫描一次数据库，查询过期的订单然后进行处理；

优点：

* 简单，容易实现；

缺点：

* 存在延迟（延迟时间不准确），如果你每隔1分钟扫一次，那么就有可能延迟1分钟；
* 性能较差，每次扫描数据库，如果订单量很大



## 6.2 被动取消

当用户查询订单的时候，判断订单是否超时，超时了就取消（交易关闭）；

优点：

* 对服务器而言，压力小；

缺点：

* 用户不查询订单，将永远处于待支付状态，会对数据统计等功能造成影响；
* 用户打开订单页面，有可能比较慢，因为要处理大量订单，用户体验稍差；



## 6.3 JDK延迟队列

`DelayedQueue`：无界阻塞队列，队列中的元素只有当其延迟时间到了，才能从队列中取出。如果尝试获取一个尚未到期的元素，操作将会被阻塞直到元素到期。

优点：

* 实现简单，任务延迟低；

缺点：

* 服务重启、宕机，数据丢失；（该队列存储在内存中）
* 只适合单机版，不适合集群；（不能分布式下）
* 订单量大，可能内存不足而发生异常； oom



## 6.4 消息中间件

RabbitMQ本身不支持延迟队列，可以使用 TTL(生存时间) 结合 DLX(死信交换机) 的方式来实现消息的延迟投递，即把DLX跟某个队列绑定，到了指定时间，消息过期后，就会从DLX路由到这个队列，消费者可以从这个队列取走消息。

### 6.4.1 正常延迟

所有的消息的延迟时间都相同。

这里采用同一个交换机，既做为正常交换机，也做为死信交换机

![img](F:\JavaCode\MessageQueue\RabbitMQ\document\image\wps1-1744013814142-1.jpg)

* 配置文件

  ```yml
  server:
    port: 8080
  
  spring:
    application:
      name: ttl-delay2
  
    rabbitmq:
      host: 111.119.211.126
      port: 5672
      username: admin
      password: *****
      virtual-host: zw
  
  my:
    exchangeName: exchange.delay.1 # 交换机(既做为正常交换机，也做为死信交换机)
    queueNormalName: queue.delay.normal.1
    queueDlxName: queue.delay.dlx.1
  ```

* 配置类

  ```java
  @Configuration
  @Data
  @ConfigurationProperties(prefix = "my")
  public class RabbitConfig {
      private String exchangeName;
      private String queueNormalName;
      private String queueDlxName;
  
      // 创建交换机
      @Bean
      public DirectExchange directExchange(){
          return ExchangeBuilder.directExchange(exchangeName).build();
      }
  
      // 创建正常消息队列
      @Bean
      public Queue queueNormal(){
          return QueueBuilder.durable(queueNormalName)
                  .expires(25000) // 设置过期时间
                  .deadLetterExchange(exchangeName) // 绑定死信交换机(自身)
                  .deadLetterRoutingKey("error") // 绑定死信路由key
                  .build();
      }
  
      // 创建死信消息队列
      @Bean
      public Queue queueDlx(){
          return QueueBuilder.durable(queueDlxName).build();
      }
  
      // 绑定正常队列到交换机
      @Bean
      public Binding bindingNormal(DirectExchange directExchange, Queue queueNormal){
          return BindingBuilder.bind(queueNormal).to(directExchange).with("order");
      }
  
      // 绑定死信队列到死信交换机
      @Bean
      public Binding bindingDlx(DirectExchange directExchange, Queue queueDlx){
          return BindingBuilder.bind(queueDlx).to(directExchange).with("error");
      }
  }
  ```

所存在的问题：

![image-20250407164823783](F:\JavaCode\MessageQueue\RabbitMQ\document\image\image-20250407164823783.png)

如上如所示，如果先发送的消息延迟时间过长，而后发送的消息延迟时间较短，那么前面的消息会影响后面的消息的消费，因为队列满足先进先出的特点。

**解决办法：不同延迟时间的消费要发送到不同的队列上，同一个队列上的消息的延迟时间应该相同**

![img](F:\JavaCode\MessageQueue\RabbitMQ\document\image\wps2-1744015852111-3.jpg)
