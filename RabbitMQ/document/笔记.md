# 一. RabbitMQ简介

## 1.1 什么是RabbitMQ？

* RabbitMQ是一个广泛使用的消息服务器，采用Erlang语言编写，是一种开源的实现 AMQP（高级消息队列协议）的**消息中间件**；

* RabbitMQ最初起源于金融系统，它的性能及稳定性都非常出色；

* AMQP协议（http://www.amqp.org），即 Advanced Message Queuing Protocol，高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计；

* 官网：https://www.rabbitmq.com

  github地址：https://github.com/rabbitmq



## 1.2 消息中间件

* 简单来说，消息中间件（MQ=Message Queue）就是指保存数据的一个容器（服务器），可以用于两个系统之间的数据传递。

* 消息中间件一般有三个主要角色：生产者、消费者、消息代理(消息队列、消息服务器)；

  ![image-20250401143324331](F:\JavaCode\MessageQueue\RabbitMQ\document\image\image-20250401143324331.png)

  生产者发送消息到消息服务器，然后消费者从消息代理（消息队列）中获取数据并进行处理；

* 常用的消息中间件：

  * RabbitMQ
  * kafka（大数据领域）
  * RocketMQ（阿里巴巴开源）献给Apache组织
  * pulsar（最近一两年流行起来的）



## 1.3 MQ的使用场景

### 1.3.1 异步处理

用户下订单---向MQ 发消息--》积分系统，红包系统，手机短信系统接收消息

![img](F:\JavaCode\MessageQueue\RabbitMQ\document\image\wps2.jpg)

* 用户下单之后，系统可能会给用户加积分，发红包，发短信提醒等操作。这些操作共用时700ms，但实际上用户只关心是否下单成功，因此可以只执行一步，其他的几步发MQ消息，让其余的程序去执行。

* 同步是阻塞的（会造成等待），异步是非阻塞的（不会等待）；

* 大流量高并发请求、批量数据传递，就可以采用异步处理，提升系统吞吐量；

### 1.3.2 系统解耦

多个系统之间，不需要直接交互，通过消息进行业务流转；

![img](F:\JavaCode\MessageQueue\RabbitMQ\document\image\wps3.jpg)

以前可能A系统直接与B、C、D系统交互，现在则不需要了。

### 1.3.3 流量削峰

高负载请求/任务的缓冲处理；

![img](F:\JavaCode\MessageQueue\RabbitMQ\document\image\wps4.jpg)

例如双十一等，同一时间可能有非常多的流量直接访问数据库，此时使用MQ可以匀速的接收，接收一点处理一点。

### 1.3.4 日志处理

**主要是用kafka这个服务器**来做；

日志处理是指将消息队列用于在日志处理中，比如Kafka解决大量日志传输的问题；

loger.info(.....)

ELK 日志处理解决方案：

loger.error(.....) -->logstash收集消息--> 发送消息的kafka --> elastic search (es) -->Kibana ELK日志处理平台



# 二. RabbitMQ的安装与运行

## 2.1 运行环境搭建

RabbitMQ是使用Erlang语言开发的，所以要先下载安装Erlang

### 2.1.1 Erlang及RabbitMQ安装版本的选择

* ***下载时一定要注意版本兼容性***
* 版本兼容说明地址：https://www.rabbitmq.com/which-erlang.html

![image-20250401144938088](F:\JavaCode\MessageQueue\RabbitMQ\document\image\image-20250401144938088.png)

### 2.1.2 下载Erlang

* Erlang官网：https://www.erlang.org/

* Linux下载：

  ```
  wget https://github.com/erlang/otp/releases/download/OTP-25.1.1/otp_src_25.1.1.tar.gz
  ```

### 2.1.3 安装Erlang

* 安装erlang前先安装Linux依赖库

  ```
  yum -y install make gcc gcc-c++ kernel-devel m4 ncurses-devel openssl-devel
  ```

* 解压erlang压缩包文件

  ```
  tar -zxvf otp_src_25.1.1.tar.gz
  ```

* 配置

  ```
  cd otp_src_25.1.1
  ./configure
  ```

* 编译

  ```
  make
  ```

* 安装

  ```
  make install
  ```

  * 安装好了erlang后可以将解压的文件夹删除：

  ```
  rm -rf otp_src_25.1.1
  ```

* 验证erlang是否安装成功

  在命令行输入： erl 如果进入了编程命令行则表示安装成功，然后按ctrl + z 退出编程命令行；



### 2.1.4 下载RabbitMQ

从RabbitMQ官网https://www.rabbitmq.com找到下载链接

Linux：下载3.10.11

```
wget https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.10.11/rabbitmq-server-generic-unix-3.10.11.tar.xz
```

### 2.1.5 安装RabbitMQ

* 解压RabbitMQ的压缩包，即安装完成，无需再编译

  ```
  tar -xvf rabbitmq-server-generic-unix-3.10.11.tar.xz  -C  /usr/local/
  ```

  此时RabbitMQ就装好了



## 2.2 启动及停止RabbitMQ

### 2.2.1 启动RabbitMQ

* 切换到安装目录的sbin目录下: 

  ```
  ./rabbitmq-server  -detached
  ```

  -detached 将表示在后台启动运行rabbitmq；不加该参数表示前台启动；

* rabbitmq的运行日志存放在安装目录的var目录下；

  ```
  /usr/local/rabbitmq_server-3.10.11/var/log/rabbitmq
  ```

### 2.2.2 查看RabbitMQ的状态

* 切换到sbin目录下执行：

  ```
  ./rabbitmqctl -n rabbit status
  ```

  -n rabbit 是指定节点名称为rabbit，目前只有一个节点，节点名默认为rabbit

  此处-n rabbit 也可以省略

### 2.2.3 停止RabbitMQ

* 切换到sbin目录下执行：

  ```
  ./rabbitmqctl shutdown
  ```

### 2.3.4 配置path环境变量

* 修改配置文件

  ```
  vi /etc/profile
  ```

* 添加如下：

  ```
  RABBIT_HOME=/usr/local/rabbitmq_server-3.10.11
  PATH=$PATH:$RABBIT_HOME/sbin
  
  export RABBIT_HOME PATH
  ```

* 刷新环境变量

  ```
  source /etc/profile
  ```

  配置完环境变量之后就可以在任意位置启动RabbitMQ了





# 三. 管理命令与管理后台插件

**`./rabbitmqctl`  是一个管理命令，可以管理rabbitmq的很多操作**

**`./rabbitmqctl help`可以查看一下有哪些操作**

**查看具体子命令 可以使用 `./rabbitmqctl help 子命令名称`**



## 3.1 用户管理

用户管理包括增加用户，删除用户，查看用户列表，修改用户密码。

这些操作都是通过rabbitmqctl管理命令来实现完成。

查看帮助：`rabbitmqctl add_user --help`

1. 查看当前用户列表

   ```
   rabbitmqctl list_users
   ```

2. 新增一个用户

   ```
   语法：rabbitmqctl add_user Username Password
   示例：rabbitmqctl add_user zhangsan 123456
   ```

3. 设置用户角色

   ```
   rabbitmqctl set_user_tags User Tag
   示例：rabbitmqctl set_user_tags admin administrator
   ```

4. 设置用户权限

   ```
   rabbitmqctl set_permissions -p / admin ".*" ".*" ".*"
   ```

   说明：此操作是设置admin用户拥有操作虚拟主机/下的所有权限

5. 查看用户权限

   ```
   rabbitmqctl list_permissions
   ```

   

## 3.2 web 管理后台(插件)

Rabbitmq有一个web管理后台，这个管理后台是以插件的方式提供的，启动后台web管理功能，切换到sbin目录下执行：

```
# 查看rabbitmq 的插件列表
./rabbitmq-plugins list
#启用
./rabbitmq-plugins enable rabbitmq_management 
#禁用
./rabbitmq-plugins disable rabbitmq_management
```

### 3.2.1 防火墙设置

```
systemctl status firewalld --检查防火墙状态
systemctl stop firewalld --关闭防火墙，Linux重启之后会失效
systemctl disable firewalld --防火墙置为不可用，Linux重启后，防火墙服务不自动启动，依然是不可用
```

### 3.2.2 访问

```
http://192.168.131.131:15672 
用户名/密码为我们上面创建的admin/123456
注意上面改成你的虚拟主机的ip地址
```

备注：如果使用默认用户guest、密码guest登录，会提示User can only log in via localhost 

说明guest用户只能从localhost本机登录，所以不要使用该用户。

### 3.2.3 通过web页面新建虚拟主机

![image-20250401163938842](F:\JavaCode\MessageQueue\RabbitMQ\document\image\image-20250401163938842.png)

建完之后如下：

![image-20250401164046282](F:\JavaCode\MessageQueue\RabbitMQ\document\image\image-20250401164046282.png)





# 四. 工作模型与交换机

## 4.1 模型简介

![image-20250401164428888](F:\JavaCode\MessageQueue\RabbitMQ\document\image\image-20250401164428888.png)

消息队列有三个核心要素： **消息生产者、消息队列、消息消费者；**

* 生产者（Producer）：发送消息的应用；（java程序，也可能是别的语言写的程序）
* 消费者（Consumer）：接收消息的应用；（java程序，也可能是别的语言写的程序）
* 连接（Connection）：连接RabbitMQ服务器的TCP长连接；
* 信道（Channel）：连接中的一个虚拟通道，消息队列发送或者接收消息时，都是通过信道进行的；

* 虚拟主机（Virtual host）：一个虚拟分组，在代码中就是一个字符串，当多个不同的用户使用同一个RabbitMQ服务时，可以划分出多个Virtual host，每个用户在自己的Virtual host创建exchange/queue等；（分类比较清晰、相互隔离）
* 交换机（Exchange）：交换机负责从生产者接收消息，并根据交换机类型分发到对应的消息队列中，起到一个路由的作用；
* 路由键（Routing Key）：交换机根据路由键来决定消息分发到哪个队列，路由键是消息的目的地址；
* 绑定（Binding）：绑定是队列和交换机的一个关联连接（关联关系）；
* 队列（Queue）：存储消息的缓存；
* 消息（Message）：由生产者通过RabbitMQ发送给消费者的信息；（消息可以任何数据，字符串、user对象，json串等等）



## 4.2 交换机

Exchange（X） 可翻译成交换机/交换器/路由器

### 4.2.1 交换机类型

1. Fanout Exchange 扇形交换机
2. Direct Exchange 直连交换机
3. Topic Exchange 主题交换机
4. Headers Exchange 头部交换机

### 4.2.2 Fanout Exchange

#### 介绍

* Fanout 扇形的，散开的； 扇形交换机

* 投递到所有绑定的队列，不需要路由键，不需要进行路由键的匹配，相当于广播、群发；（只要消息队列和交换机绑定了，就会发给该消息队列）

  ![img](F:\JavaCode\MessageQueue\RabbitMQ\document\image\wps1.jpg)

#### 示例

**<font size="4px">发送消息到消息队列</font>**

* 添加依赖

  ```xml
  <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-amqp</artifactId>
  </dependency>
  ```

* 配置信息

  ```yml
  spring:
    rabbitmq:
      host: 111.119.211.126
      port: 5672 # 5672是rabbitmq默认端口  15672是管理后台的端口
      username: admin
      password: ****** # 密码
      virtual-host: zw # 虚拟主机
  ```

* 配置类RabbitConfig

  ```java
  @Configuration
  public class RabbitConfig {
      // 1.定义交换机
      @Bean
      public FanoutExchange fanoutExchange(){
          return new FanoutExchange("exchange.fanout");
      }
  
      // 2.定义队列
      @Bean
      public Queue queueA(){
          // 注意这里的Queue是org.springframework.amqp.core.Queue
          return new Queue("queue.fanout.a");
      }
      @Bean
      public Queue queueB(){
          // 注意这里的Queue是org.springframework.amqp.core.Queue
          return new Queue("queue.fanout.b");
      }
  
      // 3.绑定交换机和队列
      @Bean
      public Binding bindingA(FanoutExchange fanoutExchange, Queue queueA){
          // 绑定队列A到交换机
          return BindingBuilder.bind(queueA).to(fanoutExchange);
      }
      @Bean
      public Binding bindingB(FanoutExchange fanoutExchange, Queue queueB){
          // 绑定队列A到交换机
          return BindingBuilder.bind(queueB).to(fanoutExchange);
      }
  }
  ```

* 发送消息的Service类

  ```java
  @Component
  @Slf4j
  public class MessageService {
      @Autowired
      private RabbitTemplate rabbitTemplate;
  
      public void sendMessage(){
          // 定义要发送的消息
          String msg = "helloworld";
          Message message = new Message(msg.getBytes());
          // 发送消息
          // 参数1：交换机名称，
          // 参数2：路由key， (扇形交换机不需要路由key，它将消息广播给与它相连的所有消息队列)
          // 参数3：消息
          rabbitTemplate.convertAndSend("exchange.fanout", "", message);
          log.info("发送消息完毕，发送时间：{}", new Date());
      }
  }
  ```

* 主启动类

  ```java
  @SpringBootApplication
  // 实现ApplicationRunner接口，在项目启动后，执行run方法
  public class Application implements ApplicationRunner {
  
      @Autowired
      private MessageService messageService;
  
      public static void main(String[] args) {
          SpringApplication.run(Application.class, args);
      }
  
      /**
       * 启动任务，程序一启动就会执行
       * @param args
       * @throws Exception
       */
      @Override
      public void run(ApplicationArguments args) throws Exception {
          // 发送消息，消息先到扇形交换机exchange.fanout
          // 然后转发给与它相连的所有消息队列queue.fanout.a和queue.fanout.b
          messageService.sendMessage();
      }
  }
  ```

**<font size="4px">从消息队列接收消息</font>**

* 添加依赖

  ```xml
  <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-amqp</artifactId>
  </dependency>
  ```

* 配置文件

  ```yml
  spring:
    rabbitmq:
      host: 111.119.211.126
      port: 5672 # 5672是rabbitmq默认端口  15672是管理后台的端口
      username: admin
      password: 123456
      virtual-host: zw # 虚拟主机
  ```

* 接收消息类

  ```java
  @Component
  @Slf4j
  public class ReceiveMessage {
      // 接收两个队列的消息
      @RabbitListener(queues={"queue.fanout.a","queue.fanout.b"})
      public void receiveMessage(Message message){
          byte[] body = message.getBody();// 消息体
          String msg = new String(body);
          log.info("接收到消息：{}", msg);
      }
  }
  ```

### 4.2.3 Direct Exchange

#### 介绍

直连交换机

根据路由键精确匹配（一模一样，区分大小写）进行路由消息队列；

例如以下结构：一个生产者，一个交换机，两个消息队列，两个消费者

* 如果路由key为Hello，则不会进入队列
* 如果路由key为error，会进入两个队列
* 如果路由key为info，只会进入第二个队列

![img](F:\JavaCode\MessageQueue\RabbitMQ\document\image\wps2-1743571452683-4.jpg)

#### 示例

**<font size="4px">发送消息到消息队列</font>**

* 引入依赖

* 配置文件 

  ```yml
  server:
    port: 8080
  
  spring:
    application:
      name: direct-exchange
  
    rabbitmq:
      host: 111.119.211.126
      port: 5672
      username: admin
      password: ******
      virtual-host: zw
  
  my:
    exchangeName: exchange.direct
    queueAName: queue.direct.a
    queueBName: queue.direct.b
  ```

* 配置类，配置交换机和消息队列

  ```java
  @Configuration
  @ConfigurationProperties(prefix = "my")
  public class RabbitConfig {
      private String exchangeName;
      private String queueAName;
      private String queueBName;
  
      // 创建交换机
      @Bean
      public DirectExchange directExchange() {
          return ExchangeBuilder.directExchange(exchangeName).build();
      }
  
      // 创建消息队列
      @Bean
      public Queue queueA() {
          return QueueBuilder.durable(queueAName).build();
      }
      @Bean
      public Queue queueB(){
          return QueueBuilder.durable(queueBName).build();
      }
  
      // 绑定交换机和队列
      @Bean
      public Binding bindingA(DirectExchange directExchange, Queue queueA) {
          // 将queueA绑定到directExchange交换机，并指定路由键为error
          return BindingBuilder.bind(queueA).to(directExchange).with("error");
      }
      @Bean
      public Binding bindingB1(DirectExchange directExchange, Queue queueB) {
          return BindingBuilder.bind(queueB).to(directExchange).with("error");
      }
  
      @Bean
      public Binding bindingB2(DirectExchange directExchange, Queue queueB) {
          return BindingBuilder.bind(queueB).to(directExchange).with("info");
      }
  
      @Bean
      public Binding bindingB3(DirectExchange directExchange, Queue queueB) {
          return BindingBuilder.bind(queueB).to(directExchange).with("warning");
      }
  }
  ```

* 发送消息

  ```java
  @Service
  @Slf4j
  public class MessageService {
      @Autowired
      private RabbitTemplate rabbitTemplate;
  
      public void sendMessage() {
          // 创建消息
          Message message = MessageBuilder.withBody("你好世界".getBytes()).build();
          // 往交换机exchange.direct上发消息，路由key是hello
          // 参数1：交换机名称，
          // 参数2：路由key，
          // 参数3：消息
          // 这里消息的路由key是hello与消息队列的都不匹配，因此消息会被交换机直接丢弃
  //        rabbitTemplate.convertAndSend("exchange.direct", "hello", message);
          rabbitTemplate.convertAndSend("exchange.direct", "info", message);
          log.info("发送消息完毕，发送时间：{}", new Date());
      }
  }
  ```

* 主启动类

  ```java
  @SpringBootApplication
  public class DirectApplication implements ApplicationRunner {
  
      @Autowired
      private MessageService messageService;
  
      public static void main(String[] args) {
          SpringApplication.run(DirectApplication.class, args);
      }
  
      @Override
      public void run(ApplicationArguments args) throws Exception {
          messageService.sendMessage(); // 发送消息
      }
  }
  ```

  **<font size=4px>接收消息</font>**

  ```java
  @Component
  @Slf4j
  public class ReceiveMessage {
  	// 发送消息的路由key为"info",因此只有队列queue.direct.b能接收到消息
      @RabbitListener(queues={"queue.direct.b"})
      public void receiveMessage(Message message){
          byte[] body = message.getBody();// 消息体
          String msg = new String(body);
          log.info("接收到消息：{}", msg);
      }
  }
  ```

### 4.3.4 Topic Exchange

#### 介绍

* Topic Exchange 主题交换机

* 通配符匹配，相当于模糊匹配；

  * `#`匹配多个单词，用来表示任意数量（零个或多个）单词
  * `*`匹配一个单词（必须有一个，而且只有一个），用.隔开的为一个单词：

  ```
  beijing.# == beijing.queue.abc, beijing.queue.xyz.xxx
  beijing.* == beijing.queue, beijing.xyz
  ```

  ![img](F:\JavaCode\MessageQueue\RabbitMQ\document\image\wps3-1743576067943-6.jpg)

#### 示例

**<font size=4px>发送消息</font>**

发送时指定的路由键：lazy.orange.rabbit

注意虽然这个key与Q2的两个都匹配，但进入队列的只有一条消息

* 配置类

  ```java
  @Configuration
  @Data
  @ConfigurationProperties(prefix = "my")
  public class RabbitConfig {
      private String exchangeName;
      private String queueAName;
      private String queueBName;
  
      // 创建交换机
      @Bean
      public TopicExchange topicExchange(){
          return ExchangeBuilder.topicExchange(exchangeName).build();
      }
  
      // 创建消息队列
      @Bean
      public Queue queueA(){
          // durable:开启持久化
          return QueueBuilder.durable(queueAName).build();
      }
      @Bean
      public Queue queueB(){
          return QueueBuilder.durable(queueBName).build();
      }
  
      // 绑定队列到交换机
      @Bean
      public Binding bindingA(TopicExchange topicExchange, Queue queueA){
          return BindingBuilder.bind(queueA).to(topicExchange).with("*.orange.*");
      }
      @Bean
      public Binding bindingB1(TopicExchange topicExchange, Queue queueB){
          return BindingBuilder.bind(queueB).to(topicExchange).with("*.*.rabbit");
      }
      @Bean
      public Binding bindingB2(TopicExchange topicExchange, Queue queueB){
          return BindingBuilder.bind(queueB).to(topicExchange).with("laze.#");
      }
  }
  ```

* 发送消息服务类

  ```java
  @Service
  public class MessageService {
      @Autowired
      private AmqpTemplate amqpTemplate; // amqp是协议，RabbitTemplate是amqp的实现
  
      public void sendMessage(){
          Message message = MessageBuilder.withBody("法外狂徒张三".getBytes()).build();
          amqpTemplate.convertAndSend("exchange.topic", "hello.world", message);
      }
  }
  ```

* 启动类

  ```java
  SpringBootApplication
  public class TopicApplication implements ApplicationRunner {
  
      @Autowired
      private MessageService messageService;
  
      public static void main(String[] args) {
          SpringApplication.run(TopicApplication.class, args);
      }
  
      @Override
      public void run(ApplicationArguments args) throws Exception {
          messageService.sendMessage();// 发送消息到主题交换机
      }
  }
  ```

### 4.3.5 Headers Exchange

#### 介绍

* Headers Exchange：头部交换机 （使用较少）
* 发消息时除了消息体，还可以包括消息头部
* **头部交换机与路由没有关系，不是通过路由来匹配的**

![img](F:\JavaCode\MessageQueue\RabbitMQ\document\image\wps4-1743580692274-8.jpg)

#### 示例

**<font size=4px>发送消息</font>**

* 配置类

  ```java
  @Configuration
  @Data
  @ConfigurationProperties(prefix = "my")
  public class RabbitConfig {
      private String exchangeName;
      private String queueAName;
      private String queueBName;
  
      // 创建交换机
      @Bean
      public HeadersExchange headersExchange(){
          return ExchangeBuilder.headersExchange(exchangeName).build();
      }
  
      // 创建消息队列
      @Bean
      public Queue queueA(){
          return QueueBuilder.durable(queueAName).build();
      }
      @Bean
      public Queue queueB(){
          return QueueBuilder.durable(queueBName).build();
      }
  
      // 绑定队列到交换机
      @Bean
      public Binding bindingA(HeadersExchange headersExchange, Queue queueA){
          Map<String, Object> headersValue = new HashMap<>();
          headersValue.put("type", "m");
          headersValue.put("status", "1");
          return BindingBuilder.bind(queueA).to(headersExchange).whereAll(headersValue).match();
      }
      @Bean
      public Binding bindingB1(HeadersExchange headersExchange, Queue queueB){
          Map<String, Object> headersValue = new HashMap<>();
          headersValue.put("type", "s");
          headersValue.put("status", "0");
          return BindingBuilder.bind(queueB).to(headersExchange).whereAll(headersValue).match();
      }
  }
  ```

* 发送消息的服务类

  ```java
  @Service
  @Slf4j
  public class MessageService {
      @Autowired
      private RabbitTemplate rabbitTemplate;
  
      public void sendMessage(){
          // 创建消息属性对象
          MessageProperties messageProperties = new MessageProperties();
          Map<String, Object> headersValue = new HashMap<>();
          // 发送到B队列
          headersValue.put("type", "s");
          headersValue.put("status", "0");
          messageProperties.setHeaders(headersValue); // 设置消息头
  
          // 消息
          Message message = MessageBuilder.withBody("头部交换机".getBytes()).
                  andProperties(messageProperties).build();
  
          rabbitTemplate.convertAndSend("exchange.headers", "", message);
          log.info("发送消息完毕，发送时间：{}", new Date());
      }
  }
  ```







# 五. 过期消息与死信

## 5.1 简介

过期消息也叫TTL消息，TTL：Time To Live 

消息的过期时间有两种设置方式：（过期消息）



## 5.2 设置消息的过期时间

### 5.2.1 设置单条消息的过期时间 

采用直连交换机，过期时间在消息属性中设置

```java
@Service
@Slf4j
public class MessageService {
    @Autowired
    private RabbitTemplate rabbitTemplate;

    public void sendMessage() {
        // 创建消息属性
        MessageProperties messageProperties = new MessageProperties();
        messageProperties.setExpiration("35000"); // 单位毫秒
        // 创建消息
        Message message = MessageBuilder.withBody("消息过期时间".getBytes())
                .andProperties(messageProperties).build();
        // 发送消息
        rabbitTemplate.convertAndSend("exchange.ttl.a", "info", message);
        log.info("发送消息完毕，发送时间：{}", new Date());
    }
}
// 单条消息的过期时间决定了在没有任何消费者消费时，消息可以存活多久；
```

![image-20250402175124004](F:\JavaCode\MessageQueue\RabbitMQ\document\image\image-20250402175124004.png)

如果消息在过期时间之内被接收了，消息就不会过期，之后给服务器一个响应，告诉服务器可以删除该消息了。虽然最后这条消息还是被删了，但不是因为过期被删除的。

### 5.2.2 通过队列属性设置消息过期时间

创建消息队列时设置队列的过期时间

```java
// 创建消息队列
@Bean
public Queue queue(){
    Map<String, Object> arguments = new HashMap<>();
    arguments.put("x-message-ttl", 30000); // 设置队列的过期时间

    // 方式一：使用 new Queue 的方式
    // Queue(String name, boolean durable, boolean exclusive, boolean autoDelete, Map arguments)
    // name: 队列名称
    // durable: 是否持久化
    // exclusive: 是否是排他队列
    // autoDelete: 是否自动删除
    // arguments: 其他参数
    // return new Queue(queueName, true, false, false, null);

    // 方式二：建造者模式
    return QueueBuilder.durable(queueName)
            .withArguments(arguments)
            .build();
}
// 队列的过期时间决定了在没有任何消费者的情况下，队列中的消息可以存活多久；
```

**注意事项：如果消息和对列都设置过期时间，则消息的TTL以两者之间较小的那个数值为准。**



## 5.3 死信队列

### 5.3.1 介绍

* 死信：过期的消息就被称为死信，

* 死信交换机：Dead-Letter-Exchange (DLX) 。这是**一个普通的交换机**，它可以是任何类型的交换机（direct、topic、headers、fanout等）。**当一条消息由于某些原因未能成功被消费（如消息过期、队列长度限制导致消息被拒绝等），这条消息可以被重新发送到一个指定的死信交换机。**通过配置原始队列的参数，可以指定如果消息成为“死信”时应该发送到哪个死信交换机。

* 死信队列：这是**绑定到死信交换机上的一个普通队列**。一旦消息被标记为死信，并且被发送到死信交换机后，根据绑定规则（binding keys等），这些**消息会被路由到对应的死信队列**中。开发者可以通过监听死信队列来处理这些未能成功处理的消息，比如进行日志记录、错误分析或者尝试重新处理等操作。

  ![image-20250402213816596](F:\JavaCode\MessageQueue\RabbitMQ\document\image\image-20250402213816596.png)

* 以下情况下消息会进入死信队列：
  * 消息过期
  * 队列过期
  * 队列达到最大长度（先入队的消息会被发送到DLX）
  * 消费者拒绝消息不进行重新投递
  * 消费者拒绝消息



### 5.3.2 队列过期

**<font size=4>案例</font>**

利用死信交换机来实现订单超时功能，假设用户下单之后会向交换机发送一条消息，经过路由key（这里设置为`order`）到达消息队列。这个消息队列没有任何消费者，我们设置队列的过期时间为35秒，20秒过后就会进入到死信交换机中，然后经过路由到达死信队列，死信队列的消费者拿到这条消息之后，就可以去数据库比对该订单是否支付了，如果支付了，则什么也不用做。如果没支付，就关闭交易，关闭交易之后就不能支付了。

![image-20250402214718441](F:\JavaCode\MessageQueue\RabbitMQ\document\image\image-20250402214718441.png)

**<font size=4>重点: 为正常的消息队列设置死信交换机，并设置其路由key，保证进入死信交换机的消息能顺利到达死信队列</font>**

**<font size=4>代码</font>**

* 配置文件：

  ```yml
  server:
    port: 8080
  
  spring:
    application:
      name: dlx-learn1
  
    rabbitmq:
      host: 111.119.211.126
      port: 5672
      username: admin
      password: *******
      virtual-host: zw
  
  my:
    exchangeNormalName: exchange.normal.a # 正常交换机名称
    queueNormalName: queue.normal.a # 正常队列名称
    exchangeDlxName: exchange.dlx.a # 死信交换机名称
    queueDlxName: queue.dlx.a # 死信队列名称
  ```

* 配置类。配置消息队列与交换机

  ```java
  @Configuration
  @ConfigurationProperties("my")
  @Data
  public class RabbitConfig {
      private String exchangeNormalName; // 正常交换机名称
      private String queueNormalName; // 正常队列名称
      private String exchangeDlxName; // 死信交换机名称
      private String queueDlxName; // 死信队列名称
  
      // 创建正常交换机
      @Bean
      public DirectExchange normalExchange() {
          return new DirectExchange(exchangeNormalName);
      }
      // 创建正常队列
      @Bean
      public Queue normalQueue(){
          // 设置队列的属性
          Map<String, Object> arguments = new HashMap<>();
          arguments.put("x-message-ttl", 35000); // 设置队列的过期时间
          arguments.put("x-dead-letter-exchange", exchangeDlxName); // 设置队列的死信交换机
          arguments.put("x-dead-letter-routing-key", "error"); // 设置队列的死信路由key
          return new Queue(queueNormalName, true, false, false, arguments);
      }
      // 绑定正常交换机和正常队列
      @Bean
      public Binding bindingNormal(DirectExchange normalExchange, Queue normalQueue) {
          return BindingBuilder.bind(normalQueue).to(normalExchange).with("order");
      }
  
      // 创建死信交换机
      @Bean
      public DirectExchange dlxExchange() {
          return ExchangeBuilder.directExchange(exchangeDlxName).build();
      }
      // 创建死信队列
      @Bean
      public Queue dlxQueue(){
          return QueueBuilder.durable(queueDlxName).build();
      }
      // 绑定死信交换机和死信队列
      @Bean
      public Binding bindingDlx(DirectExchange dlxExchange, Queue dlxQueue){
          return BindingBuilder.bind(dlxQueue).to(dlxExchange).with("error");
      }
  }
  ```

* 发送消息的服务类

  ```java
  @Service
  @Slf4j
  public class MessageService {
      @Autowired
      private RabbitTemplate rabbitTemplate;
  
      public void sendMsg(){
          Message message = MessageBuilder.withBody("订单1".getBytes()).build();
          // 发送消息
          rabbitTemplate.convertAndSend("exchange.normal.a", "order", message);
          log.info("发送消息完毕，发送时间：{}", new Date());
      }
  }
  ```

* 启动类

  ```java
  @SpringBootApplication
  public class Dlx1Application implements ApplicationRunner {
  
      @Autowired
      private MessageService messageService;
  
      public static void main(String[] args) {
          SpringApplication.run(Dlx1Application.class, args);
      }
  
      @Override
      public void run(ApplicationArguments args) throws Exception {
          messageService.sendMsg();
      }
  }
  ```



### 5.3.3 消息过期

**<font size=4>代码</font>**

* 配置文件

  ```yml
  server:
    port: 8080
  
  spring:
    application:
      name: dlx-learn2
  
    rabbitmq:
      host: 111.119.211.126
      port: 5672
      username: admin
      password: ****
      virtual-host: zw
  
  my:
    exchangeNormalName: exchange.normal.2 # 正常交换机名称
    queueNormalName: queue.normal.2 # 正常队列名称
    exchangeDlxName: exchange.dlx.2 # 死信交换机名称
    queueDlxName: queue.dlx.2 # 死信队列名称
  ```

* 配置类，配置交换机和消息队列

  ```java
  @Configuration
  @ConfigurationProperties("my")
  @Data
  public class RabbitConfig {
      private String exchangeNormalName; // 正常交换机名称
      private String queueNormalName; // 正常队列名称
      private String exchangeDlxName; // 死信交换机名称
      private String queueDlxName; // 死信队列名称
  
      // 创建正常交换机
      @Bean
      public DirectExchange normalExchange() {
          return new DirectExchange(exchangeNormalName);
      }
      // 创建正常队列
      @Bean
      public Queue normalQueue(){
          // 也可以采用建造者模式来绑定死信交换机和死信路由key
          return QueueBuilder.durable(queueNormalName)
                  .deadLetterExchange(exchangeDlxName) // 绑定死信交换机
                  .deadLetterRoutingKey("error") // 绑定死信路由key
                  .build();
      }
      // 绑定正常交换机和正常队列
      @Bean
      public Binding bindingNormal(DirectExchange normalExchange, Queue normalQueue) {
          return BindingBuilder.bind(normalQueue).to(normalExchange).with("order");
      }
  
      // 创建死信交换机
      @Bean
      public DirectExchange dlxExchange() {
          return ExchangeBuilder.directExchange(exchangeDlxName).build();
      }
      // 创建死信队列
      @Bean
      public Queue dlxQueue(){
          return QueueBuilder.durable(queueDlxName).build();
      }
      // 绑定死信交换机和死信队列
      @Bean
      public Binding bindingDlx(DirectExchange dlxExchange, Queue dlxQueue){
          return BindingBuilder.bind(dlxQueue).to(dlxExchange).with("error");
      }
  }
  ```

* 发送消息的Service类。在这里设置消息的过期时间

  ```java
  @Service
  @Slf4j
  public class MessageService {
      @Autowired
      private RabbitTemplate rabbitTemplate;
  
      public void sendMsg(){
          // 消息属性
          MessageProperties messageProperties = new MessageProperties();
          messageProperties.setExpiration("30000"); // 设置过期时间，单位为毫秒
          // 创建消息
          Message message = MessageBuilder.withBody("订单2".getBytes()).andProperties(messageProperties).build();
          // 发送消息
          rabbitTemplate.convertAndSend("exchange.normal.2", "order", message);
          log.info("发送消息完毕，发送时间：{}", new Date());
      }
  }
  ```




### 5.3.4 队列达到最大长度

队列达到最大长度之后，先入队的消息会被发送到死信交换机。

在创建正常的消息队列时为其设置最大长度属性

```java
// 设置队列的最大长度

// 方法一：
// 设置队列的属性
Map<String, Object> arguments = new HashMap<>();
//设置队列的最大长度 ，对头的消息会被挤出变成死信
arguments.put("x-max-length", 5);
arguments.put("x-dead-letter-exchange", exchangeDlxName); // 设置队列的死信交换机
arguments.put("x-dead-letter-routing-key", "error"); // 设置队列的死信路由key
// return new Queue(queueNormalName, true, false, false, arguments);
return QueueBuilder.durable(queueNormalName).withArguments(arguments).build();

// 方法二：建造者模式
return QueueBuilder.durable(queueNormalName)
        .maxLength(5)
        .deadLetterExchange(exchangeDlxName) // 绑定死信交换机
        .deadLetterRoutingKey("error") // 绑定死信路由key
        .build();
```



### 5.3.5 消费者拒绝消息不进行重新投递

之前我们的模型中，生产的消息没有消费者。现在我们给其添加消费者。从正常的队列接收消息，但是对消息不进行确认，并且不对消息进行重新投递，此时消息就进入死信队列。

![image-20250407104818073](F:\JavaCode\MessageQueue\RabbitMQ\document\image\image-20250407104818073.png)

* 配置文件：开启手动确认

  ```yml
  # 在消费者端进行配置
  spring:
    rabbitmq:
      listener:
        type: direct
        direct:
          acknowledge-mode: manual
  
  # 注意如果不指定type，要将direct改成simple，手动确认才会生效
  spring:
    rabbitmq:
      listener:
        simple:
          acknowledge-mode: manual
  ```

* 接收端：

  ```java
  @Component
  @Slf4j
  public class MessageReceive {
      /**
       * 接收消息
       * @param message 消息
       * @param channel 信道 所有的消息接收和发送都通过信道
       */
      @RabbitListener(queues = {"queue.normal.4"})
      public void receive(Message message, Channel channel) {
          // 获取消息属性
          MessageProperties messageProperties = message.getMessageProperties();
          // 获取消息的唯一标识
          long deliveryTag = messageProperties.getDeliveryTag();
          try{
              // 接收消息并做后序处理，例如更新数据库
              String msg = new String(message.getBody());
              log.info("接收到消息：{}, 接收时间为{}", msg, new Date());
              // 处理成功，确认消息
              channel.basicAck(deliveryTag, false);
          } catch (Exception e){
              log.error("接收者出现问题，原因是{}", e.getMessage());
              try {
                  // 不确认并重新入队
                  // channel.basicNack(deliveryTag, false, true);
                  
                  // 拒绝消息并且不重新入队
                  channel.basicReject(deliveryTag, false);
              } catch (IOException ex) {
                  ex.printStackTrace();
              }
          }
      }
  }
  ```

  * 两个方法原型

    ```java
    // deliveryTag：消息的一个数字标签，唯一标识
    // multiple如果是true表示对小于deliveryTag标签下的消息都进行确认，false表示只确认当前的一条消息
    void basicAck(long deliveryTag, boolean multiple);
    
    // deliveryTag：消息的一个数字标签，唯一标识
    // multiple: true表示对小于deliveryTag标签下的消息都进行不确认，false表示只不确认当前的一条消息
    // requeue: true表示重新放入队列中，理论上可以被再次消费，false表示被丢弃或发送到死信交换机中
    void basicNack(long deliveryTag, boolean multiple, boolean requeue);
    
    // deliveryTag：消息的一个数字标签，唯一标识
    // requeue: 是否重新入队
    void basicReject(long deliveryTag, boolean requeue);
    ```





# 六. 延迟队列

场景：有一个订单，15分钟内如果不支付，就把该订单设置为交易关闭，那么就不能支付了，这类实现延迟任务的场景就可以采用延迟队列来实现，当然除了延迟队列来实现，也可以有一些其他办法实现；

## 6.1 定时任务方式

每隔3秒扫描一次数据库，查询过期的订单然后进行处理；

优点：

* 简单，容易实现；

缺点：

* 存在延迟（延迟时间不准确），如果你每隔1分钟扫一次，那么就有可能延迟1分钟；
* 性能较差，每次扫描数据库，如果订单量很大



## 6.2 被动取消

当用户查询订单的时候，判断订单是否超时，超时了就取消（交易关闭）；

优点：

* 对服务器而言，压力小；

缺点：

* 用户不查询订单，将永远处于待支付状态，会对数据统计等功能造成影响；
* 用户打开订单页面，有可能比较慢，因为要处理大量订单，用户体验稍差；



## 6.3 JDK延迟队列

`DelayedQueue`：无界阻塞队列，队列中的元素只有当其延迟时间到了，才能从队列中取出。如果尝试获取一个尚未到期的元素，操作将会被阻塞直到元素到期。

优点：

* 实现简单，任务延迟低；

缺点：

* 服务重启、宕机，数据丢失；（该队列存储在内存中）
* 只适合单机版，不适合集群；（不能分布式下）
* 订单量大，可能内存不足而发生异常； oom



## 6.4 消息中间件

RabbitMQ本身不支持延迟队列，可以使用 TTL(生存时间) 结合 DLX(死信交换机) 的方式来实现消息的延迟投递，即把DLX跟某个队列绑定，到了指定时间，消息过期后，就会从DLX路由到这个队列，消费者可以从这个队列取走消息。

### 6.4.1 正常延迟

所有的消息的延迟时间都相同。

这里采用同一个交换机，既做为正常交换机，也做为死信交换机

![img](F:\JavaCode\MessageQueue\RabbitMQ\document\image\wps1-1744013814142-1.jpg)

* 配置文件

  ```yml
  server:
    port: 8080
  
  spring:
    application:
      name: ttl-delay2
  
    rabbitmq:
      host: 111.119.211.126
      port: 5672
      username: admin
      password: *****
      virtual-host: zw
  
  my:
    exchangeName: exchange.delay.1 # 交换机(既做为正常交换机，也做为死信交换机)
    queueNormalName: queue.delay.normal.1
    queueDlxName: queue.delay.dlx.1
  ```

* 配置类

  ```java
  @Configuration
  @Data
  @ConfigurationProperties(prefix = "my")
  public class RabbitConfig {
      private String exchangeName;
      private String queueNormalName;
      private String queueDlxName;
  
      // 创建交换机
      @Bean
      public DirectExchange directExchange(){
          return ExchangeBuilder.directExchange(exchangeName).build();
      }
  
      // 创建正常消息队列
      @Bean
      public Queue queueNormal(){
          return QueueBuilder.durable(queueNormalName)
                  .expires(25000) // 设置过期时间
                  .deadLetterExchange(exchangeName) // 绑定死信交换机(自身)
                  .deadLetterRoutingKey("error") // 绑定死信路由key
                  .build();
      }
  
      // 创建死信消息队列
      @Bean
      public Queue queueDlx(){
          return QueueBuilder.durable(queueDlxName).build();
      }
  
      // 绑定正常队列到交换机
      @Bean
      public Binding bindingNormal(DirectExchange directExchange, Queue queueNormal){
          return BindingBuilder.bind(queueNormal).to(directExchange).with("order");
      }
  
      // 绑定死信队列到死信交换机
      @Bean
      public Binding bindingDlx(DirectExchange directExchange, Queue queueDlx){
          return BindingBuilder.bind(queueDlx).to(directExchange).with("error");
      }
  }
  ```



### 6.4.2 消息延迟时间不同

正常延迟所存在的问题：

![image-20250407164823783](F:\JavaCode\MessageQueue\RabbitMQ\document\image\image-20250407164823783.png)

如上如所示，如果先发送的消息延迟时间过长，而后发送的消息延迟时间较短，那么前面的消息会影响后面的消息的消费，因为队列满足先进先出的特点。

**解决办法：不同延迟时间的消费要发送到不同的队列上，同一个队列上的消息的延迟时间应该相同**



![img](F:\JavaCode\MessageQueue\RabbitMQ\document\image\wps2-1744015852111-3.jpg)

* 配置文件

  ```yml
  server:
    port: 8080
  
  spring:
    application:
      name: delay-learn3
  
    rabbitmq:
      host: 111.119.211.126
      port: 5672
      username: admin
      password: *****
      virtual-host: zw
  
  my:
    exchangeName: exchange.delay.3 # 交换机(既做为正常交换机，也做为死信交换机)
    queueOrderName: queue.delay.order.3 # 订单队列
    queuePayName: queue.delay.pay.3 # 支付队列
    queueDlxName: queue.delay.dlx.3
  ```

* 配置类

  ```java
  @Configuration
  @Data
  @ConfigurationProperties(prefix = "my")
  public class RabbitConfig {
      private String exchangeName;
      private String queueOrderName;
      private String queuePayName;
      private String queueDlxName;
  
      // 创建交换机
      @Bean
      public DirectExchange directExchange(){
          return ExchangeBuilder.directExchange(exchangeName).build();
      }
  
      // 创建订单队列
      @Bean
      public Queue queueOrder(){
          return QueueBuilder.durable(queueOrderName)
                  .ttl(25000) // 设置过期时间
                  .deadLetterExchange(exchangeName) // 绑定死信交换机(自身)
                  .deadLetterRoutingKey("error") // 绑定死信路由key
                  .build();
      }
  
      // 创建支付队列
      @Bean
      public Queue queuePay(){
          return QueueBuilder.durable(queuePayName)
                  .ttl(15000) // 设置过期时间
                  .deadLetterExchange(exchangeName) // 绑定死信交换机(自身)
                  .deadLetterRoutingKey("error") // 绑定死信路由key
                  .build();
      }
  
      // 创建死信消息队列
      @Bean
      public Queue queueDlx(){
          return QueueBuilder.durable(queueDlxName).build();
      }
  
      // 绑定订单队列到交换机
      @Bean
      public Binding bindingOrder(DirectExchange directExchange, Queue queueOrder){
          return BindingBuilder.bind(queueOrder).to(directExchange).with("order");
      }
  
      // 绑定订单队列到交换机
      @Bean
      public Binding bindingPay(DirectExchange directExchange, Queue queuePay){
          return BindingBuilder.bind(queuePay).to(directExchange).with("pay");
      }
  
      // 绑定死信队列到死信交换机
      @Bean
      public Binding bindingDlx(DirectExchange directExchange, Queue queueDlx){
          return BindingBuilder.bind(queueDlx).to(directExchange).with("error");
      }
  }
  ```

* 发送消息服务类

  ```java
  @Service
  @Slf4j
  public class MessageService {
      @Autowired
      private RabbitTemplate rabbitTemplate;
  
      public void sendMessage() {
          {
              // 创建消息
              Message message = MessageBuilder.withBody("订单消息1".getBytes()).build();
              // 发送消息
              rabbitTemplate.convertAndSend("exchange.delay.3", "order", message);
              log.info("发送消息完毕，发送时间：{}", new Date());
          }
  
          {
              // 创建消息
              Message message = MessageBuilder.withBody("支付消息1".getBytes()).build();
              // 发送消息
              rabbitTemplate.convertAndSend("exchange.delay.3", "pay", message);
              log.info("发送消息完毕，发送时间：{}", new Date());
          }
      }
  }
  ```

* 接收消息

  ```java
  @Component
  @Slf4j
  public class ReceiveMessage {
      @RabbitListener(queues={"queue.delay.4"})
      public void receiveMessage(Message message){
          String body = new String(message.getBody());
          log.info("接收到消息：{}, 时间为{}", body, new Date());
      }
  }
  ```



## 6.5 使用延迟插件

`rabbitmq-delayed-message-exchange`插件

1. 下载插件

   * 选择对应的版本下载 rabbitmq-delayed-message-exchange 插件，

   * 下载地址：http://www.rabbitmq.com/community-plugins.html 

   * 下载到rabbitmq的安装目录的plugins目录下

     ![image-20250412140907371](F:\JavaCode\MessageQueue\RabbitMQ\document\image\image-20250412140907371.png)

     ![image-20250412141639424](F:\JavaCode\MessageQueue\RabbitMQ\document\image\image-20250412141639424.png)

2. 解压

   ```
   unzip rabbitmq_delayed_message_exchange-3.10.2.ez
   ```

   如果没有unzip 先安装一下

   ```
   yum install unzip -y
   ```

3. 启用插件

   ```
   rabbitmq-plugins enable rabbitmq_delayed_message_exchange
   ```

   `rabbitmq-plugins list` 查看所有插件



### 6.4.1 使用插件

安装该插件之后，交换机类型会多一种

![image-20250412142740680](F:\JavaCode\MessageQueue\RabbitMQ\document\image\image-20250412142740680.png)

![image-20250412142931170](F:\JavaCode\MessageQueue\RabbitMQ\document\image\image-20250412142931170.png)

* 消息发送后不会直接投递到队列，而是存储到 Mnesia（嵌入式数据库），检查 x-delay 时间（**延迟时间需要设置到消息头部里**）；
* 延迟插件在 RabbitMQ 3.5.7 及以上的版本才支持，依赖 Erlang/OPT 18.0 及以上运行环境；

* **Mnesia 是一个小型数据库，不适合于大量延迟消息的实现** （正常消息都存放在这个数据库里）
* 只需要一个交换机和一个消息队列即可，消息经过交换机先存储到Mnesia数据库中，等到消息过期了在转到消息队列中。
* **解决了消息过期时间不一致出现的问题**



### 6.4.2 代码实现

* 配置文件

  ```yml
  server:
    port: 8080
  
  spring:
    application:
      name: delay-learn4
  
    rabbitmq:
      host: 111.119.211.126
      port: 5672
      username: admin
      password: *****
      virtual-host: zw
  
  my:
    exchangeName: exchange.delay.4 # 延迟交换机
    queueDelayName: queue.delay.4 # 延迟消息队列
  ```

* 配置类

  ```java
  @Configuration
  @Data
  @ConfigurationProperties(prefix = "my")
  public class RabbitConfig {
      private String exchangeName;
      private String queueDelayName;
  
      // 创建自定义交换机
      @Bean
      public CustomExchange customExchange(){
          // 注意这里交换机不是直连交换机了，而是x-delayed-message类型的交换机
          // 因此需要自定义交换机
          // CustomExchange(String name, String type, boolean durable, boolean autoDelete, Map<String, Object> arguments)
          // name: 交换机名称
          // type: 交换机类型
          // durable: 是否持久化
          // autoDelete: 是否自动删除,ture表示自动删除，当所有与该交换机绑定的队列都断开连接后，该交换机自动删除
          // arguments: 其他参数，这里使用x-delayed-message类型的交换机的参数
          Map<String, Object> arguments = new HashMap<>();
          arguments.put("x-delayed-type", "direct");
          return new CustomExchange(exchangeName, "x-delayed-message", true, false,arguments);
      }
  
      // 创建消息队列
      @Bean
      public Queue queue(){
          // 不需要设置死信路由key了
          return QueueBuilder.durable(queueDelayName)
                  .deadLetterExchange(exchangeName) // 绑定死信交换机(自身)
                  .build();
      }
  
      // 绑定队列到交换机
      @Bean
      public Binding bindingNormal(CustomExchange customExchange, Queue queue){
          // 这里需要指定路由key
          return BindingBuilder.bind(queue).to(customExchange).with("plugin").noargs();
      }
  }
  ```

* 发送消息服务类

  ```java
  @Service
  @Slf4j
  public class MessageService {
      @Autowired
      private RabbitTemplate rabbitTemplate;
  
      public void sendMessage() {
          {
              // 创建消息
              // 注意这里设置消息的过期时间需要使用setHeader
              Message message = MessageBuilder.withBody("消息1".getBytes()).setHeader("x-delay", 25000).build();
              // 发送消息
              rabbitTemplate.convertAndSend("exchange.delay.4", "plugin", message);
              log.info("发送消息完毕，发送时间：{}", new Date());
          }
  
          {
              // 创建消息
              Message message = MessageBuilder.withBody("消息2".getBytes()).setHeader("x-delay", 15000).build();
              // 发送消息
              rabbitTemplate.convertAndSend("exchange.delay.4", "plugin", message);
              log.info("发送消息完毕，发送时间：{}", new Date());
          }
      }
  }
  ```

* 接收消息

  ```java
  @Component
  @Slf4j
  public class ReceiveMessage {
      @RabbitListener(queues={"queue.delay.4"})
      public void receiveMessage(Message message){
          String body = new String(message.getBody());
          log.info("接收到消息：{}, 时间为{}", body, new Date());
      }
  }
  ```





# 七. 消息可靠性投递

## 7.1 简介

​	消息的可靠性投递就是要保证消息投递过程中每一个环节都要成功，那么这肯定会牺牲一些性能，性能和可靠性是无法兼得的。

​	如果业务实时性一致性要求不是特别高的场景，可以牺牲一些可靠性来换取性能。

![image-20250412160802855](F:\JavaCode\MessageQueue\RabbitMQ\document\image\image-20250412160802855.png)

1. ①表示消息从生产者发送到Exchange 

   * 确保消息发送到RabbitMQ服务器的交换机上
   * key错误，消息就不会进入交换机
   * 可能因为网络或者Broker(服务器)的问题导致①失败，而此时应该让生产者知道消息是否正确发送到了Broker的exchange中；
   * 两种解决方案
     * 第一种是开启Confirm（确认）模式；（异步）
     * 第二种是开启Transaction（事务）模式；（性能低，实际项目中很少用）

2. ②表示消息从Exchange路由到Queue（key错误，消息就不会进入队列）

   * 确保消息路由到正确的队列。可能因为路由关键字错误，或者队列不存在，或者队列名称错误导致②失败。
   * 使用return模式，可以实现消息无法路由的时候返回给生产者；当然在实际生产环境下，我们不会出现这种问题，我们都会进行严格测试才会上线（很少有这种问题）；
   * 另一种方式就是使用备份交换机（alternate-exchange），无法路由的消息会发送到这个备用交换机上；

3. ③表示消息在Queue中存储 （服务器重启，队列如果没有持久化，那么队列就丢了）

   * 确保消息在队列正确地存储。可能因为系统宕机、重启、关闭等等情况导致存储在队列的消息丢失，即③出现问题

   * 解决方案

     * 队列持久化： `QueueBuilder.durable(QUEUE).build()`

     * 交换机持久化：`ExchangeBuilder.directExchange(EXCHANGE).durable(true).build();`

     * 消息持久化:

       ```java
       MessageProperties messageProperties = new MessageProperties();
       //设置消息持久化，当然它默认就是持久化，所以可以不用设置，可以查看源码
       messageProperties.setDeliveryMode(MessageDeliveryMode.PERSISTENT); 
       ```

     * 集群，镜像队列，高可用

4. ④表示消费者监听Queue并消费消息

   * 采用消息消费时的手动ack确认机制来保证；

   * 如果消费者收到消息后未来得及处理即发生异常，或者处理过程中发生异常，会导致④失败。为了保证消息从队列可靠地达到消费者，RabbitMQ提供了消息确认机制（message acknowledgement）；

     ```properties
     #开启手动ack消息消费确认
     spring.rabbitmq.listener.simple.acknowledge-mode=manual
     ```

   * 如果消息消费失败，也可以调用basicReject()或者basicNack()来拒绝当前消息而不是确认。

   * 如果requeue参数设置为true，可以把这条消息重新存入队列，以便发给下一个消费者（当然，只有一个消费者的时候，这种方式可能会出现无限循环重复消费的情况，可以投递到新的队列中，或者只打印异常日志）；



## 7.2 Confirm模式

### 7.2.1 Confirm模式简介

​	消息的confirm确认机制，是指生产者投递消息后，到达了消息服务器Broker里面的exchange交换机，则会给生产者一个应答，生产者接收到应答，用来确定这条消息是否正常的发送到Broker的exchange中，这也是消息可靠性投递的重要保障。

![img](F:\JavaCode\MessageQueue\RabbitMQ\document\image\wps1-1744447456517-1.jpg)

### 7.2.2 具体代码

1. 配置文件开启生产者确认模式

2. 写一个类实现`RabbitTemplate.ConfirmCallback`。判断成功和失败的ack结果，可以根据具体的结果，如果ack为false，对消息进行重新发送或记录日志等处理；设置rabbitTemplate的确认回调方法。

3. 使用`rabbitTemplate.setConfirmCallback`设置回调。

   

* 配置文件开启生产者确认模式

  ```yml
  server:
    port: 8080
  
  spring:
    application:
      name: confirm-learn1
  
    rabbitmq:
      host: 111.119.211.126
      port: 5672
      username: admin
      password: ******
      virtual-host: zw
      publisher-confirm-type: correlated # 开启生产者的确认机制，设置关联模式
  
  my:
    exchangeName: exchange.confirm.1
    queueName: queue.confirm.1
  ```

* 配置类

  ```java
  @Configuration
  @Data
  @ConfigurationProperties(prefix = "my")
  public class RabbitConfig {
      private String exchangeName;
      private String queueName;
  
      // 创建交换机
      @Bean
      public DirectExchange directExchange(){
          return ExchangeBuilder.directExchange(exchangeName).build();
      }
  
      // 创建消息队列
      @Bean
      public Queue queue(){
          return QueueBuilder.durable(queueName).build();
      }
  
      // 绑定队列到交换机
      @Bean
      public Binding binding(DirectExchange directExchange, Queue queue){
          return BindingBuilder.bind(queue).to(directExchange).with("info");
      }
  }
  ```

* 编写一个类实现`RabbitTemplate.ConfirmCallback`接口

  ```java
  /**
   * ConfirmCallback 接口是一个函数式接口，只有一个抽象的confirm方法
   * 设置了回调之后，不管消息是否到达交换机，都会回调confirm方法
   */
  @Component
  @Slf4j
  public class MyConfirmCallback implements RabbitTemplate.ConfirmCallback {
      @Override
      public void confirm(CorrelationData correlationData, boolean ack, String cause) {
          String id = null; // 获取发送消息时所关联的数据
          if (correlationData != null) {
              id = correlationData.getId();
          }
          log.info("消息id：{}", id);
          
          if (ack) {
              log.info("消息成功到达交换机");
              return;
          }
          log.error("消息没有到达交换机，原因为：{}", cause);
      }
  }
  ```

* 发送消息

  ```java
  @Service
  @Slf4j
  public class MessageService {
      @Autowired
      private RabbitTemplate rabbitTemplate;
      @Autowired
      private MyConfirmCallback myConfirmCallback;
  
      @PostConstruct // 构造方法执行之后执行，相当于初始化作用
      public void init(){
          // 设置回调
          rabbitTemplate.setConfirmCallback(myConfirmCallback);
      }
  
      public void sendMessage() {
          // 创建消息
          Message message = MessageBuilder.withBody("订单消息".getBytes()).build();
          // 发送消息
          CorrelationData correlationData = new CorrelationData(); // 关联数据
          correlationData.setId("123456"); // 订单id
          rabbitTemplate.convertAndSend("exchange.confirm.a", "info", message, correlationData);
          log.info("发送消息完毕，发送时间：{}", new Date());
      }
  }
  ```



**注意：我们也可以不用另外编写`MyConfirmCallback`类，可以直接在`MessageService`类上实现`RabbitTemplate.ConfirmCallback`接口**

```java
@Service
@Slf4j
public class MessageService implements RabbitTemplate.ConfirmCallback {
    @Autowired
    private RabbitTemplate rabbitTemplate;

    @PostConstruct // 构造方法执行之后执行，相当于初始化作用
    public void init(){
        rabbitTemplate.setConfirmCallback(this);
    }

    public void sendMessage() {
        // 创建消息
        Message message = MessageBuilder.withBody("订单消息".getBytes()).build();
        // 发送消息
        CorrelationData correlationData = new CorrelationData(); // 关联数据
        correlationData.setId("123456"); // 订单id
        rabbitTemplate.convertAndSend("exchange.confirm.1", "info", message, correlationData);
        log.info("发送消息完毕，发送时间：{}", new Date());
    }


    @Override
    public void confirm(CorrelationData correlationData, boolean ack, String cause) {
        String id = null; // 获取发送消息时所关联的数据
        if (correlationData != null) {
            id = correlationData.getId();
        }
        log.info("消息id：{}", id);

        if (ack) {
            log.info("消息成功到达交换机");
            return;
        }
        log.error("消息没有到达交换机，原因为：{}", cause);
    }
}
```



**还可以使用匿名内部类的方式**

```java
@Service
@Slf4j
public class MessageService{
    @Autowired
    private RabbitTemplate rabbitTemplate;

    @PostConstruct // 构造方法执行之后执行，相当于初始化作用
    public void init(){
        rabbitTemplate.setConfirmCallback(new RabbitTemplate.ConfirmCallback() {
            @Override
            public void confirm(CorrelationData correlationData, boolean ack, String cause) {
                String id = null; // 获取发送消息时所关联的数据
                if (correlationData != null) {
                    id = correlationData.getId();
                }
                log.info("消息id：{}", id);

                if (ack) {
                    log.info("消息成功到达交换机");
                    return;
                }
                log.error("消息没有到达交换机，原因为：{}", cause);
            }
        });
    }

    public void sendMessage() {
        // 创建消息
        Message message = MessageBuilder.withBody("订单消息".getBytes()).build();
        // 发送消息
        CorrelationData correlationData = new CorrelationData(); // 关联数据
        correlationData.setId("123456"); // 订单id
        rabbitTemplate.convertAndSend("exchange.confirm.1", "info", message, correlationData);
        log.info("发送消息完毕，发送时间：{}", new Date());
    }
}
```



**由于该接口是函数式接口，也可以将匿名内部类改成lambda表达式**

```java
@Service
@Slf4j
public class MessageService{
    @Autowired
    private RabbitTemplate rabbitTemplate;

    @PostConstruct // 构造方法执行之后执行，相当于初始化作用
    public void init(){
        rabbitTemplate.setConfirmCallback((correlationData, ack, cause) -> {
            String id = null; // 获取发送消息时所关联的数据
            if (correlationData != null) {
                id = correlationData.getId();
            }
            log.info("消息id：{}", id);

            if (ack) {
                log.info("消息成功到达交换机");
                return;
            }
            log.error("消息没有到达交换机，原因为：{}", cause);
        });
    }

    public void sendMessage() {
        // 创建消息
        Message message = MessageBuilder.withBody("订单消息1111".getBytes()).build();
        // 发送消息
        CorrelationData correlationData = new CorrelationData(); // 关联数据
        correlationData.setId("123456"); // 订单id
        rabbitTemplate.convertAndSend("exchange.confirm.1", "info", message, correlationData);
        log.info("发送消息完毕，发送时间：{}", new Date());
    }
}
```



## 7.3 Return模式

rabbitmq 整个消息投递的路径为：
producer —> exchange —> queue —> consumer

> > 消息从 producer 到 exchange 则会返回一个 `confirmCallback`；
> > 消息从 exchange –> queue 投递失败则会返回一个 `returnCallback`；

我们可以利用这两个callback控制消息的可靠性投递。

### 7.3.1 步骤

1. 配置文件application.yml 开启退回模式；

2. 写一个类`MyReturnsCallback`实现`RabbitTemplate.ReturnsCallback`接口

3. 使用rabbitTemplate.setReturnsCallback设置退回函数，当消息从exchange路由到

   queue失败后，则会将消息退回给producer，并执行回调函数returnedMessage；



### 7.3.2 代码

* 配置文件

  ```yml
  server:
    port: 8080
  
  spring:
    application:
      name: return-learn1
  
    rabbitmq:
      host: 111.119.211.126
      port: 5672
      username: admin
      password: *****
      virtual-host: zw
      publisher-returns: true # 开启return机制
  
  my:
    exchangeName: exchange.return.a
    queueName: queue.return.a
  ```

* 配置类

  ```java
  @Configuration
  @Data
  @ConfigurationProperties(prefix = "my")
  public class RabbitConfig {
      private String exchangeName;
      private String queueName;
  
      // 创建交换机
      @Bean
      public DirectExchange directExchange(){
          return ExchangeBuilder.directExchange(exchangeName).build();
      }
  
      // 创建消息队列
      @Bean
      public Queue queue(){
          return QueueBuilder.durable(queueName).build();
      }
  
      // 绑定队列到交换机
      @Bean
      public Binding binding(DirectExchange directExchange, Queue queue){
          return BindingBuilder.bind(queue).to(directExchange).with("info");
      }
  }
  ```

* `MyReturnCallback`类

  ```java
  @Component
  @Slf4j
  public class MyReturnsCallback implements RabbitTemplate.ReturnsCallback{
      /**
       * 消息返回   这个方法只有在消息没有到达消息队列时才会执行
       * @param returnedMessage 这是一个封装了所有关于返回消息信息的对象，包括：
       *      getMessage(): 返回实际的消息。
       *      getReplyCode(): 获取回复码，表示返回的原因。
       *      getReplyText(): 获取回复文本，提供了关于返回原因的详细描述。
       *      getExchange(): 获取消息最初被发布的交换机名称。
       *      getRoutingKey(): 获取消息发布时使用的路由键。
       */
      @Override
      public void returnedMessage(ReturnedMessage returnedMessage) {
          log.error("消息没有正确路由到消息队列,原因为{}",returnedMessage.getReplyText());
      }
  }
  ```

* 发送消息的服务类

  ```java
  @Service
  @Slf4j
  public class MessageService{
      @Autowired
      private RabbitTemplate rabbitTemplate;
      @Autowired
      private MyReturnsCallback myReturnsCallback;
  
      @PostConstruct
      public void init() {
          rabbitTemplate.setReturnsCallback(myReturnsCallback); // 设置消息返回的回调
      }
  
      public void sendMessage() {
  
          // 创建消息
          Message message = MessageBuilder.withBody("消息".getBytes()).build();
          // 发送消息
          rabbitTemplate.convertAndSend("exchange.return.a", "error", message);
          log.info("发送消息完毕，发送时间：{}", new Date());
      }
  }
  ```



**注意：我们也可以不用另外编写`MyReturnsCallback`类，可以直接在`MessageService`类上实现`RabbitTemplate.ReturnsCallback`接口**

```java
@Service
@Slf4j
public class MessageService implements RabbitTemplate.ReturnsCallback {
    @Autowired
    private RabbitTemplate rabbitTemplate;

    @PostConstruct
    public void init() {
        rabbitTemplate.setReturnsCallback(this); // 设置消息返回的回调
    }

    public void sendMessage() {

        // 创建消息
        Message message = MessageBuilder.withBody("消息".getBytes()).build();
        // 发送消息
        rabbitTemplate.convertAndSend("exchange.return.b", "info", message);
        log.info("发送消息完毕，发送时间：{}", new Date());
    }

    @Override
    public void returnedMessage(ReturnedMessage returnedMessage) {
        log.error("消息没有正确路由到消息队列,原因为{}",returnedMessage.getReplyText());
    }
}
```



**匿名内部类方式**

```java
@Service
@Slf4j
public class MessageService{
    @Autowired
    private RabbitTemplate rabbitTemplate;

    @PostConstruct
    public void init() {
        rabbitTemplate.setReturnsCallback(new RabbitTemplate.ReturnsCallback() {
            @Override
            public void returnedMessage(ReturnedMessage returnedMessage) {
                log.error("消息没有正确路由到消息队列,原因为{}",returnedMessage.getReplyText());
            }
        }); // 设置消息返回的回调
    }

    public void sendMessage() {

        // 创建消息
        Message message = MessageBuilder.withBody("消息".getBytes()).build();
        // 发送消息
        rabbitTemplate.convertAndSend("exchange.return.b", "error", message);
        log.info("发送消息完毕，发送时间：{}", new Date());
    }
}
```



**Lambda表达式**

```java
@Service
@Slf4j
public class MessageService{
    @Autowired
    private RabbitTemplate rabbitTemplate;

    @PostConstruct
    public void init() {
        rabbitTemplate.setReturnsCallback((returnedMessage) -> log.error("消息没有正确路由到消息队列,原因为{}",returnedMessage.getReplyText()));
    }

    public void sendMessage() {

        // 创建消息
        Message message = MessageBuilder.withBody("消息".getBytes()).build();
        // 发送消息
        rabbitTemplate.convertAndSend("exchange.return.b", "error", message);
        log.info("发送消息完毕，发送时间：{}", new Date());
    }
}
```



## 7.4 交换机详细属性 持久化

### 7.4.1 具体参数

1. Name：交换机名称；就是一个字符串

2. Type：交换机类型，direct, topic, fanout, headers四种

3. Durability：持久化，声明交换机是否持久化，代表交换机在服务器重启后是否还存在； 默认为持久化

4. Auto delete：是否自动删除，曾经有队列绑定到该交换机，后来全部解绑了，那就会自动删除该交换机； 默认不是自动删除

5. Internal：内部使用的，如果是yes，客户端无法直接发消息到此交换机，它**只能用于交换机与交换机的绑定。**

6. Arguments：只有一个取值alternate-exchange，表示备用交换机；



### 7.4.2 代码演示

* 配置文件

  ```yml
  server:
    port: 8080
  
  spring:
    application:
      name: ttl-learn1
  
    rabbitmq:
      host: 111.119.211.126
      port: 5672
      username: admin
      password: ******
      virtual-host: zw
  
  my:
    exchangeName: exchange.properties.a
    queueName: queue.exchange.a
  ```

* 配置类

  ```java
  @Configuration
  @Data
  @ConfigurationProperties(prefix = "my")
  public class RabbitConfig {
      private String exchangeName;
      private String queueName;
  
      // 创建交换机
      @Bean
      public DirectExchange directExchange(){
          return ExchangeBuilder.directExchange(exchangeName)
              //.durable(false) // 不持久化  默认为持久化
              .autoDelete() // 设置自动删除 默认不是自动删除
              .build();
      }
  
      // 创建消息队列
      @Bean
      public Queue queue(){
          return QueueBuilder.durable(queueName).build();
      }
  
      // 绑定队列到交换机
      @Bean
      public Binding binding(DirectExchange directExchange, Queue queue){
          return BindingBuilder.bind(queue).to(directExchange).with("info");
      }
  }
  ```



### 7.4.3 几个结论

1. 没发消息之前不会创建交换机和队列
2. 发送消息后，如果交换机不存在，才开始创建交换机，如果队列不存在，则创建新的队列。
3. 创建交换机或者队列完成后再重新创建，如果修改交换机或队列参数则会报错
4. 设置持久化为false ，重启rabbitmq-server，则交换机丢失
5. 自动删除为 true ，从控制台上手动解绑队列，会发现交换机自动删除



## 7.5 备用交换机

### 7.5.1 介绍

​	当消息经过交换器准备路由给队列的时候，发现没有对应的队列可以投递信息，在rabbitmq中会默认丢弃消息，如果我们想要监测哪些消息被投递到没有对应的队列，我们可以用备用交换机来实现，可以接收备用交换机的消息，然后记录日志或发送报警信息。

![image-20250413133354281](F:\JavaCode\MessageQueue\RabbitMQ\document\image\image-20250413133354281.png)

### 7.5.2 代码

我们使用direct直连交换机做为正常交换机，使用fanout扇形交换机做为备用交换机

* 配置文件

  ```yml
  server:
    port: 8080
  
  spring:
    application:
      name: rabbit-10-alternate-exchange
  
    rabbitmq:
      host: 111.119.211.126
      port: 5672
      username: admin
      password: ****
      virtual-host: zw
  
  my:
    exchangeNormalName: exchange.normal.a # 正常交换机
    exchangeAlterNateName: exchange.alternate.a # 备用交换机
    queueNormalName: queue.normal.a # 正常队列
    queueAlterNateName: queue.alternate.a # 备用队列
  ```

* 配置类

  ```java
  @Configuration
  @Data
  @ConfigurationProperties(prefix = "my")
  public class RabbitConfig {
      private String exchangeNormalName;
      private String exchangeAlterNateName;
      private String queueNormalName;
      private String queueAlterNateName;
  
      // 创建正常交换机
      @Bean
      public DirectExchange normalExchange(){
          return ExchangeBuilder.directExchange(exchangeNormalName)
                  .alternate(exchangeAlterNateName) // 设置备用交换机
                  .build();
      }
  
      // 创建正常消息队列
      @Bean
      public Queue normalQueue(){
          return QueueBuilder.durable(queueNormalName).build();
      }
  
      // 绑定正常队列到交换机
      @Bean
      public Binding binding(DirectExchange normalExchange, Queue normalQueue){
          return BindingBuilder.bind(normalQueue).to(normalExchange).with("info");
      }
  
      // 创建备用交换机
      @Bean
      public FanoutExchange alterExchange(){
          return ExchangeBuilder.fanoutExchange(exchangeAlterNateName).build();
      }
  
      // 创建备用队列
      @Bean
      public Queue alterQueue(){
          return QueueBuilder.durable(queueAlterNateName).build();
      }
  
      // 绑定备用队列到备用交换机
      @Bean
      public Binding bindingAlter(FanoutExchange alterExchange, Queue alterQueue){
          return BindingBuilder.bind(alterQueue).to(alterExchange);
      }
  }
  ```

* 发送消息服务类

  ```java
  @Service
  @Slf4j
  public class MessageService {
      @Autowired
      private RabbitTemplate rabbitTemplate;
      @Value("${my.exchangeNormalName}")
      private String exchangeName;
  
      public void sendMessage() {
          // 创建消息
          Message message = MessageBuilder.withBody("消息".getBytes()).build();
          // 发送消息
          rabbitTemplate.convertAndSend(exchangeName, "info", message);
          log.info("发送消息完毕，发送时间：{}", new Date());
      }
  }
  ```

* 接收消息类，监听备用队列

  ```java
  @Component
  @Slf4j
  public class ReceiveMessage {
      @RabbitListener(queues = "queue.alternate.a")
      public void receiveMessage(Message message) {
          log.info("接收到消息：{}", new String(message.getBody()));
          log.info("接收到消息时间：{}", new Date());
      }
  }
  ```



## 7.6 队列的详细属性

### 7.6.1 具体参数

```java
Queue(String name, boolean durable, boolean exclusive, boolean autoDelete, Map<String, Object> arguments)
```

* `Type`:  队列类型 **一般都是`Classic`**
* `Name`:  队列名称，就是一个字符串，随便一个字符串都行
* `Durability`:  队列是否持久化，代表队列在服务器重启之后是否还存在
* `Auto delete`:  是否自动删除。当最后一个消费者取消订阅或断开连接后，队列将被自动删除
* `Exclusive`:  独占性。如果设置为 true，则该队列仅能被创建它的连接使用（只有第一个连接该队列的消费者可以使用他，其他都不能使用），并且当该连接关闭时，队列将被删除。**一般设置为false**
* `Arguments`:  队列的其他属性。如TTL、死信交换机等高级功能
  * `Auto expire`:  控制整个队列的生命期。如果队列在一段时间内没有活跃使用（即没有消费者连接，并且没有任何未处理的消息），那么该队列将自动删除。设置`x-expire`参数。
  * `Message TTL`:  单个消息在其被发送到队列后可以存活的最大时间长度. 设置`x-message-ttl`参数
  * `Overflow behaviour`：设置队列溢出行为。当队列达到最大长度时，消息会发生什么。设置`x-overflow`参数。
    * `drop-head`:  当达到最大长度时，移除最早的可用消息
    * `reject-publish`: 当达到最大长度时，返回一个基本的 `basic.nack` 给发布者，通知其消息未能被接受。
    * `reject-publish-dlx`: 类似于 `reject-publish`，但如果配置了死信交换机（Dead Letter Exchange, DLX），未被接受的消息会被转发到该死信交换机。
  * `Single active consumer`:  单个活跃消费者。旨在确保某个队列的消息仅由一个消费者处理，即使有多个消费者订阅了同一个队列。这种机制可以避免多个消费者同时处理来自同一队列的消息，从而防止重复消费的问题，并且可以在某些情况下简化消息处理逻辑。设置`x-single-active-consumer`参数为true或false
  * `Dead letter exchange`:  设置死信交换机。设置`x-dead-letter-exchange`参数。
  * `Dead letter routing key`：设置死信路由key。设置`x-dead-letter-routing-key`参数。
  * `Max length`：队列的最大长度。设置`x-max-length`参数。
  * `Max length bytes`：队列最大字节长度限制。设置`x-max-length-bytes`参数。单位为字节
  * `Maximum priority`：在声明队列时设置`x-max-priority`参数来定义队列支持的最大优先级数。可以在0-255之间。发消息时为消息设置其优先级，即可实现插队消费。
  * `Lazy mode`：在声明队列时设置 `x-queue-mode` 参数为 `lazy` 来启用懒模式。当启用懒模式后，RabbitMQ 会尽可能将队列中的消息存储到磁盘上，而不是保存在内存中，这样可以显著减少内存占用，并有助于管理非常大的队列。
  * `Version`
  * `Master locator`：与队列的高可用性（HA）策略相关的概念，特别是当使用Quorum Queues时。Quorum Queues是RabbitMQ提供的一个现代队列类型，旨在提供更强的一致性和可靠性保证，适用于对数据一致性要求较高的场景。





## 7.7 消息的幂等性

### 7.7.1 介绍

幂等性：

>对于一个资源，不管你请求一次还是请求多次，对该资源本身造成的影响应该是相同的，不能因为重复的请求而对该资源重复造成影响；

消息消费时的幂等性：(消息不被重复消费)

> 同一个消息，第一次接收，正常处理业务，如果该消息第二次再接收，那就不能再处理业务，否则就处理重复了；



### 7.7.2 避免重复消费

**处理办法：全局唯一ID + Redis**

生产者在发送消息时，为每条消息设置一个全局唯一的messageId，消费者拿到消息后，使用setnx命令，将messageId作为key放到redis中：setnx(messageId, 1)，若返回1，说明之前没有消费过，正常消费；若返回0，说明这条消息之前已消费过，抛弃； （**注意需要开启消息手动确认**）

* 发送消息

  ```java
  @Service
  @Slf4j
  public class MessageService {
      @Autowired
      private RabbitTemplate rabbitTemplate;
      @Value("${my.exchangeName}")
      private String exchangeName;
      @Autowired
      private ObjectMapper objectMapper;
  
      public void sendMessage() throws JsonProcessingException {
          {
              Orders order1 = Orders.builder()
                      .orderId("order_666")
                      .orderName("手机订单")
                      .orderTime(new Date())
                      .orderPrice(new BigDecimal(6666)).build();
              String json1 = objectMapper.writeValueAsString(order1); // 转换为json串
              Message message = MessageBuilder.withBody(json1.getBytes()).build();
              rabbitTemplate.convertAndSend(exchangeName, "info", message);
              log.info("发送消息完毕，发送时间：{}", new Date());
          }
          {
              Orders order2 = Orders.builder()
                      .orderId("order_666")
                      .orderName("手机订单")
                      .orderTime(new Date())
                      .orderPrice(new BigDecimal(6666)).build();
              String json2 = objectMapper.writeValueAsString(order2); // 转换为json串
  
              // 创建消息
              Message message = MessageBuilder.withBody(json2.getBytes()).build();
              // 发送消息
              rabbitTemplate.convertAndSend(exchangeName, "info", message);
              log.info("发送消息完毕，发送时间：{}", new Date());
          }
      }
  }
  ```

* 接收消息

  ```java
  @Component
  @Slf4j
  public class ReceiveMessage {
      @Autowired
      private ObjectMapper objectMapper;
      @Autowired
      private RedisTemplate redisTemplate;
  
      @RabbitListener(queues = "${my.queueName}")
      public void receiveMessage(Message message, Channel channel) throws JsonProcessingException {
          long deliveryTag = message.getMessageProperties().getDeliveryTag(); // 获取消息的唯一标识
          String strOrder = new String(message.getBody());
          Orders order = objectMapper.readValue(strOrder, Orders.class); // 将消息转换为对象
          try{
              // 把消息的唯一ID写入redis
              // //如果redis中该key不存在，那么就设置，存在就不设置
              boolean flag = redisTemplate.opsForValue().setIfAbsent("idempotent:" + order.getOrderId(), String.valueOf(order.getOrderId()));
              if (flag) { //key不存在返回true
                  //相当于是第一次消费该消息
                  //TODO 处理业务
                  log.info("接收到消息：{}", strOrder);
                  log.info("接收到消息时间：{}", new Date());
              }
              // 手动确认
              channel.basicAck(deliveryTag, false);
          } catch (Exception e){
              log.error("消息处理出现问题");
              try {
                  channel.basicNack(deliveryTag, false, true);
              } catch (IOException ex) {
                  throw new RuntimeException(ex);
              }
          }
      }
  }
  ```





# 八. 集群与高可用

## 8.1 介绍

* RabbitMQ 的集群分两种模式，一种是**默认集群模式**，一种是**镜像集群模式**；

* 在RabbitMQ集群中所有的节点（一个节点就是一个RabbitMQ的broker服务器） 被归为两类：

  * 一类是磁盘节点，磁盘节点会把集群的所有信息（比如交换机、绑定、队列等信息）持久化到磁盘中
  * 一类是内存节点；而内存节点只会将这些信息保存到内存中，

  如果该节点宕机或重启，内存节点的数据会全部丢失，而磁盘节点的数据不会丢失；



## 8.2 默认集群模式

* 默认集群模式也叫 普通集群模式、或者 内置集群模式；  

* RabbitMQ默认集群模式，只会把交换机、队列、虚拟主机、路由key等元数据(metadata)信息在各个节点同步，而**具体队列中的消息内容不会在各个节点中同步**；

  ![image-20250413171027099](F:\JavaCode\MessageQueue\RabbitMQ\document\image\image-20250413171027099.png)

* 元数据
  * 队列元数据：队列名称和属性（是否可持久化，是否自动删除）
  * 交换器元数据：交换器名称、类型和属性
  * 绑定元数据：交换器和队列的绑定列表
  * vhost元数据：vhost内的相关属性，如安全属性等;
  * 当用户访问其中任何一个RabbitMQ节点时，查询到的queue／user／exchange/vhost等信息都是相同的；
  * **但集群中队列的具体信息数据只在队列的拥有者节点保存**，其他节点只知道队列的元数据和指向该节点的指针，所以其他节点接收到不属于该节点队列的消息时会将该消息传递给该队列的拥有者节点上；

* 为什么集群不复制队列内容和状态到所有节点：

  1）存储空间；

  2）性能；

  如果消息需要复制到集群中每个节点，网络开销不可避免，持久化消息还需要写磁盘，占用磁盘空间。

* 存在的问题：

  如果有一个消息生产者或者消息消费者通过amqp-client的客户端连接到节点1进行消息的发送或接收，那么此时集群中的消息收发只与节点1相关，这个没有任何问题；

  如果客户端相连的是节点2或者节点3 （队列1数据不在该节点上），那么情况又会是怎么样呢？

  如果消息生产者所连接的是节点2或者节点3，此时队列1的完整数据不在该两个节点上，那么在发送消息过程中这两个节点主要起了一个路由转发作用，根据这两个节点上的元数据（也就是指向queue的owner node的指针）转发至节点1上，最终发送的消息还是会存储至节点1的队列1上；

  同样，如果消息消费者所连接的节点2或者节点3，那这两个节点也会作为路由节点起到转发作用，将会从节点1的队列1中获取消息进行消费；
