# 一. MQ简介

## 1.1 为什么要使用MQ

* 要做到系统解耦，当新的模块进来时，可以做到代码改动最小;  **能够解耦**
* 设置流程缓冲池，可以让后端系统按自身吞吐能力进行消费，不被冲垮; **能够削峰，限流**
* 强弱依赖梳理能把非关键调用链路的操作异步化并提升整体系统的吞吐能力;**能够异步**

***Mq的作用  削峰限流 异步 解耦合***



## 1.2 定义

* 中间件是什么？
  * 中间件（缓存中间件  redis memcache  数据库中间件 mycat  canal   消息中间件mq ）
  * 面向消息的中间件(message-oriented middleware) MOM能够很好的解决以上的问题。是指利用高效可靠的消息传递机制进行与平台无关（跨平台）的数据交流，并基于数据通信来进行分布式系统的集成。

* 通过提供**消息传递和消息排队模型**在分布式环境下提供应用解耦，弹性伸缩，冗余存储，流量削峰，异步通信，数据同步等
* 大致流程
  * 发送者把消息发给消息服务器[MQ]，
  * 消息服务器把消息存放在若干**队列/主题**中
  * 在合适的时候，消息服务器会把消息转发给接受者。
* 在这个过程中，发送和接受是异步的,也就是发送无需等待，发送者和接受者的生命周期也没有必然关系在发布pub/订阅sub模式下，也可以完成一对多的通信，可以让一个消息有多个接受者[微信订阅号就是这样的]

![img](F:\JavaCode\MessageQueue\RocketMQ\document\image\wps1.jpg)

## 1.3 特点

### 1.3.1 异步处理模式

​	消息发送者可以发送一个消息而无需等待响应。消息发送者把消息发送到一条虚拟的通道(主题或队列)上;

​	消息接收者则订阅或监听该通道。一条信息可能最终转发给一个或多个消息接收者，这些接收者都无需对消息发送者做出回应。整个过程都是异步的。

​	也就是说，一个系统和另一个系统间进行通信的时候，假如系统A希望发送一个消息给系统B，让它去处理，但是系统A不关注系统B到底怎么处理或者有没有处理好，所以系统A把消息发送给MQ，然后就不管这条消息的“死活” 了，接着系统B从MQ里面消费出来处理即可。至于怎么处理，是否处理完毕，什么时候处理，都是系统B的事，与系统A无关。

![img](F:\JavaCode\MessageQueue\RocketMQ\document\image\wps2.jpg)

这样的一种通信方式，就是所谓的“异步”通信方式，对于系统A来说，只要把消息发给MQ,然后系统B就会异步处去进行处理了，系统A不能“同步”的等待系统B处理完。这样的好处是什么呢？**解耦**

### 1.3.2 应用系统的解耦

  发送者和接收者不必了解对方，只需要确认消息
  发送者和接收者不必同时在线

### 1.3.3 现实中的业务

![image-20250414151713214](F:\JavaCode\MessageQueue\RocketMQ\document\image\image-20250414151713214.png)



## 1.4 各种MQ产品的比较

![image-20250414151819771](F:\JavaCode\MessageQueue\RocketMQ\document\image\image-20250414151819771.png)

![image-20250414153450707](F:\JavaCode\MessageQueue\RocketMQ\document\image\image-20250414153450707.png)







# 二. RocketMQ基础

## 2.1 RocketMQ简介

* 官网：http://rocketmq.apache.org/

* 介绍：

  >RocketMQ是阿里巴巴2016年MQ中间件，使用Java语言开发，RocketMQ 是一款开源的**分布式消息系统**，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务。同时，广泛应用于多个领域，包括异步通信解耦、企业解决方案、金融支付、电信、电子商务、快递物流、广告营销、社交、即时通信、移动应用、手游、视频、物联网、车联网等。

* 具有以下特点：

  * 能够保证严格的消息顺序
  * 提供丰富的消息拉取模式
  * 高效的订阅者水平扩展能力
  * 实时的消息订阅机制
  * 亿级消息堆积能力



## 2.2 RocketMQ相关概念

* **Producer**：消息的发送者，生产者；举例：发件人
* **Consumer**：消息接收者，消费者；举例：收件人
* **Broker**：暂存和传输消息的通道；举例：快递
* **NameServer**：管理Broker；举例：各个快递公司的管理机构 相当于broker的注册中心，保留了broker的信息
* **Queue**：队列，消息存放的位置，**一个Broker中可以有多个队列**。【实际存放的是消息的地址，而不是消息本身】
* **Topic**：主题，消息的分类
* ProducerGroup：生产者组
* ConsumerGroup：消费者组，多个消费者组可以同时消费一个主题的消息



## 2.3 消息发送流程

消息发送的流程是，Producer询问NameServer，NameServer分配一个broker（每一个broker都还有从机），然后Consumer也要询问NameServer，得到一个具体的broker，然后消费消息。以下图是一个单机版的RocketMQ。

![img](F:\JavaCode\MessageQueue\RocketMQ\document\image\wps1-1746870218860-1.jpg)



## 2.4 生产和消费的理解

![img](F:\JavaCode\MessageQueue\RocketMQ\document\image\wps2-1746871954103-3.jpg)

## 2.5 安装

### 2.5.1 下载RocketMQ

* 下载地址：https://rocketmq.apache.org/zh/download

* 注意选择版本，这里我们选择4.9.2的版本，与后面使用alibaba时对应

  ![image-20250510191403080](F:\JavaCode\MessageQueue\RocketMQ\document\image\image-20250510191403080.png)

  下载bin文件



### 2.5.2 下载RocketMQ控制台

* Rocketmq 控制台可以可视化MQ的消息发送！
* 网址：https://rocketmq.apache.org/zh/docs/deploymentOperations/04Dashboard/



### 2.5.3 上传服务器

* 在root目录下新建文件夹

  ```
  mkdir rocketmq
  ```

* 将bin文件的压缩包和控制台的jar包上传上去

  ![image-20250510195533529](F:\JavaCode\MessageQueue\RocketMQ\document\image\image-20250510195533529.png)



### 2.5.4 解压

```
unzip rocketmq-all-4.9.2-bin-release.zip
```

如果你的服务器没有unzip命令，则下载安装一个

```
yum install unzip
```

目录分析：

![image-20250510195610685](F:\JavaCode\MessageQueue\RocketMQ\document\image\image-20250510195610685.png)

* Benchmark：包含一些性能测试的脚本；
* Bin：可执行文件目录；
* Conf：配置文件目录；
* Lib：第三方依赖；
* LICENSE：授权信息;
* NOTICE：版本公告；



### 2.5.5 配置环境变量

```
vim /etc/profile
```

在文件末尾添加

```
export NAMESRV_ADDR=阿里云公网IP:9876
```

刷新环境变量

```
source /etc/profile
```



### 2.5.6 修改nameServer的运行脚本

进入bin目录下，修改runserver.sh文件,将71行和76行的Xms和Xmx以及Xmn等改小一点

```
vim runserver.sh
```

![image-20250510200756427](F:\JavaCode\MessageQueue\RocketMQ\document\image\image-20250510200756427.png)



### 2.5.7 修改broker的运行脚本

进入bin目录下，修改runbroker.sh文件,修改67行

```
vim runbroker.sh
```

![image-20250510201051789](F:\JavaCode\MessageQueue\RocketMQ\document\image\image-20250510201051789.png)



### 2.5.8 修改broker的配置文件

进入conf目录下，修改broker.conf文件

```
brokerClusterName = DefaultCluster
brokerName = broker-a
brokerId = 0
deleteWhen = 04
fileReservedTime = 48
brokerRole = ASYNC_MASTER
flushDiskType = ASYNC_FLUSH
namesrvAddr=111.119.211.126:9876
autoCreateTopicEnable=true
brokerIP1=阿里云公网IP
```

* namesrvAddr：nameSrv的地址，可以写localhost，因为nameSrv和broker在一个服务器上。
* autoCreateTopicEnable：自动创建主题，不然需要手动创建出来
* brokerIP1：broker也需要一个公网ip，如果不指定，那么是阿里云的内网地址，我们再本地无法连接使用



### 2.5.9 启动nameserver和broker

* 首先在安装目录下创建一个logs文件夹，用于存放日志

  ```
  mkdir logs
  ```

  ![image-20250510210658229](F:\JavaCode\MessageQueue\RocketMQ\document\image\image-20250510210658229.png)

* 在bin目录下执行：

  * 启动nameserver

    ```
    # nohup表示在后台运行，不占用控制台
    # 执行mqnamesrv脚本文件，输出日志到namesrv.log文件中
    nohup sh mqnamesrv > ../logs/namesrv.log &
    ```

  * 启动broker

    ```
    # 这里的-c是指定使用的配置文件
    nohup sh mqbroker -c ../conf/broker.conf > ../logs/broker.log &
    ```

* 可以使用`jps -l`命令查看java应用的进程号

  ![image-20250510211326726](F:\JavaCode\MessageQueue\RocketMQ\document\image\image-20250510211326726.png)

  

### 2.5.10 启动RocketMQ控制台

```
nohup java -jar ./rocketmq-dashboard-1.0.0.jar --server.port=8001 --rocketmq.config.namesrvAddr=127.0.0.1:9876 > ./rocketmq-4.9.2/logs/dashboard.log &
```

* `--server.port=8001` : 指定端口号，默认是8080.
* `--rocketmq.config.namesrvAddr=127.0.0.1:9876`：指定namesrv地址。

![image-20250510212106851](F:\JavaCode\MessageQueue\RocketMQ\document\image\image-20250510212106851.png)

**注意要在安全组策略中放开9876和10100-11000端口。**



## 2.6 Docker部署RocketMQ

### 2.6.1 下载镜像

```
docker pull apache/rocketmq:4.9.2 # rocketmq镜像
docker pull apacherocketmq/rocketmq-dashboard:1.0.0 # 控制台镜像
```

### 2.6.2 创建容器共享网络

RocketMQ中有多个服务，需要创建多个容器，创建 docker 网络便于容器间相互通信。

```
docker network create rocketmq
```

### 2.6.3 启动NameServer

* 创建NameServer数据存储路径

  ```
  mkdir -p /root/rocketmq/data/namesrv/logs /root/rocketmq/data/namesrv/store
  ```

* 启动NameServer容器

  ```
  docker run -d --name rmqnamesrv -p 9876:9876 \
  -v /root/rocketmq/data/namesrv/logs:/root/logs \
  -v /root/rocketmq/data/namesrv/store:/root/store \
  -e "MAX_POSSIBLE_HEAP=100000000" \
  --net rocketmq \
  apache/rocketmq:4.9.2 sh mqnamesrv
  ```

* 查看是否启动成功

  ```
  docker logs -f rmqnamesrv # rmqnamesrv是容器的名字
  ```

### 2.6.4 启动Broker

* 创建Broker数据存储路径

  ```
  mkdir -p /root/rocketmq/data/broker/logs /root/rocketmq/data/broker/store
  ```

* 创建conf配置文件目录

  ```
  mkdir /root/rocketmq/conf
  ```

* 在配置文件目录下新建broker.conf配置文件，内容如下

  ```
  # 所属集群名称，如果节点较多可以配置多个
  brokerClusterName = DefaultCluster
  #broker名称，master和slave使用相同的名称，表明他们的主从关系
  brokerName = broker-a
  #0表示Master，大于0表示不同的slave
  brokerId = 0
  #表示几点做消息删除动作，默认是凌晨4点
  deleteWhen = 04
  #在磁盘上保留消息的时长，单位是小时
  fileReservedTime = 48
  #有三个值：SYNC_MASTER，ASYNC_MASTER，SLAVE；同步和异步表示Master和Slave之间同步数据的机制；
  brokerRole = ASYNC_MASTER
  #刷盘策略，取值为：ASYNC_FLUSH，SYNC_FLUSH表示同步刷盘和异步刷盘；SYNC_FLUSH消息写入磁盘后才返回成功状态，ASYNC_FLUSH不需要；
  flushDiskType = ASYNC_FLUSH
  # 设置broker节点所在服务器的ip地址
  brokerIP1 = 111.119.211.126
  ```

* 启动Broker容器

  ```
  docker run -d  --name rmqbroker \
  --link rmqnamesrv:namesrv \
  --net rocketmq \
  -p 10911:10911 -p 10909:10909 \
  -v /root/rocketmq/data/broker/logs:/root/logs \
  -v /root/rocketmq/data/broker/store:/root/store \
  -v /root/rocketmq/conf/broker.conf:/opt/rocketmq-4.9.2/conf/broker.conf \
  --privileged=true \
  -e "NAMESRV_ADDR=namesrv:9876" \
  -e "MAX_POSSIBLE_HEAP=200000000" \
  apache/rocketmq:4.9.2 \
  sh mqbroker -c /opt/rocketmq-4.9.2/conf/broker.conf
  ```

  * `--link rmqnamesrv:namesrv`：将当前容器链接到名为 `rmqnamesrv` 的另一个容器，并使用别名 `namesrv`。
  * 10911端口：主要负责处理客户端与 Broker 之间的消息收发请求。
  * 10909端口：用于 Broker 高可用部署时的数据同步，确保消息的可靠性和服务的连续性。
  * `--privileged=true`：给予容器扩展权限
  * `-e "NAMESRV_ADDR=namesrv:9876"`: 设置环境变量 `NAMESRV_ADDR`，告诉 Broker Name Server 的地址，以便与之通信。
  * `-e "MAX_POSSIBLE_HEAP=200000000"`: 设置 JVM 最大可能堆内存大小为 200,000,000 字节。
  * `sh mqbroker -c /opt/rocketmq-4.9.2/conf/broker.conf`：在容器启动时执行的命令，这里是指定使用配置文件 `/opt/rocketmq-4.4.0/conf/broker.conf` 来启动 Broker。

* 验证broker是否启动成功

  ```
  docker logs rmqbroker
  ```

### 2.6.5 启动控制台

```
docker run -d --name rmqadmin \
-e "JAVA_OPTS=-Drocketmq.namesrv.addr=111.119.211.126:9876 \
-Dcom.rocketmq.sendMessageWithVIPChannel=false \
-Duser.timezone='Asia/Shanghai'" \
-v /etc/localtime:/etc/localtime \
-p 8081:8080 \
apacherocketmq/rocketmq-dashboard:1.0.0
```

* `-Dcom.rocketmq.sendMessageWithVIPChannel=false`：关闭 VIP Channel 模式。VIP Channel 是 RocketMQ 早期版本中的一种通信方式，默认监听在 Broker 的 `10912` 端口，现在基本不用了。
* `-Duser.timezone='Asia/Shanghai'"`：设置时区为中国标准时间（UTC+8）。

### 2.6.6 访问控制台

![image-20250511170033315](F:\JavaCode\MessageQueue\RocketMQ\document\image\image-20250511170033315.png)





# 三. RocketMQ快速入门

## 3.1 消息发送和监听的流程

### 3.1.1 消息生产者

1. 创建消息生产者producer，并制定生产者组名

2. 指定Nameserver地址

3. 启动producer

4. 创建消息对象，指定主题Topic、Tag和消息体等

5. 发送消息

6. 关闭生产者producer

### 3.1.2 消息消费者

1. 创建消费者consumer，制定消费者组名

2. 指定Nameserver地址

3. 创建监听订阅主题Topic和Tag等

4. 处理消息

5. 启动消费者consumer



## 3.2 搭建项目Rocketmq-demo

### 3.2.1 加入依赖

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>

<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
    <optional>true</optional>
</dependency>

<!--rocketmq原生api-->
<dependency>
    <groupId>org.apache.rocketmq</groupId>
    <artifactId>rocketmq-client</artifactId>
    <version>4.9.2</version>
</dependency>
```

### 3.2.2 编写生产者

```java
@Test
void sendMessage() throws Exception {
    // 1. 创建一个生产者 （指定一个组名：test-producer-group）
    // DefaultMQProducer producer2 = new DefaultMQProducer("test-producer-group"); 可以为一个组创建多个生产者
    DefaultMQProducer producer = new DefaultMQProducer("test-producer-group");
    // 2. 连接NameServer
    producer.setNamesrvAddr("111.119.211.126:9876");
    // 3. 启动生产者
    producer.start();
    // 4. 创建一个消息
    //    这里用的是重载的方法，指定消息主题和内容
    Message message = new Message("testTopic", "我是一个消息".getBytes());
    // 5. 发送消息
    SendResult sendResult = producer.send(message);
    System.out.println(sendResult);
    // 6. 关闭生产者
    producer.shutdown();
}
```

创建消息的消息原型：

```
// Message(String topic, String tags, String keys, int flag, byte[] body, boolean waitStoreMsgOK)
// topic：消息所属的Topic，需要提前在NameServer创建 或者在broker.conf中配置了自动创建Topic1·1· 
// tags：消息的标签，可以理解为消息的分类
// keys：消息的Key，用于消息去重
// flag：消息的标识，用于消息去重
// body：消息的内容
// waitStoreMsgOK：是否等待消息存储到NameServer
```

* 生产者为什么要设置组名？

  >没有特殊意义。同一个生产者组的生产者，可以向多个不同的主题中发送消息。



### 3.2.3 编写消费者

```java
@Test
void consumer() throws Exception{
    // 1. 创建一个消费者 (指定一个组名：test-consumer-group)
    DefaultMQPushConsumer consumer = new DefaultMQPushConsumer("test-consumer-group");
    // DefaultMQPushConsumer consumer2 = new DefaultMQPushConsumer("test-consumer-group"); // 同一个
    // 2. 连接NameServer
    consumer.setNamesrvAddr("111.119.211.126:9876");
    // 3. 订阅主题
    //    testTopic：订阅的主题名称,  *：表示订阅所有标签(所有消息)
    consumer.subscribe("testTopic", "*");
    // 4. 设置一个监听器 (异步进行的，一直监听)
    consumer.registerMessageListener(new MessageListenerConcurrently() {
        /**
         * 消费消息 这个方法会启动一个新的线程执行，
         * @param list 消息列表
         * @param context 并发消息的上下文
         * @return
         */
        @Override
        public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> list, ConsumeConcurrentlyContext context) {
            // 这个就是消费的方法
            MessageExt messageExt = list.get(0);
            System.out.println(messageExt);
            System.out.println(new String(messageExt.getBody())); // 消息内容
            System.out.println(context);
            // 返回值是ConsumeConcurrentlyStatus,是一个枚举类型
            // 该枚举类型有两个值: CONSUME_SUCCESS, RECONSUME_LATER;
            // CONSUME_SUCCESS表示成功，消息会从mq中出队
            // RECONSUME_LATER表示失败，消息会重新入队,过一会会重新投递
            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS; // 消费成功
        }
    });
    // 5. 启动消费者
    consumer.start();

    // 6.挂起当前的jvm
    System.in.read();
}
```

![image-20250511224121716](F:\JavaCode\MessageQueue\RocketMQ\document\image\image-20250511224121716.png)

* 消费者为什么要设置组名？

  > **消费者组内的消费者订阅关系必须保持一致。**即同一个消费者组的消费者只能消费同一个主题的消息。

* 假设生产者向testTopic主题中发送了一条消息，消费者组中有两个消费者c1和c2，那么这条消息到底给谁？有两种策略:

  * 轮询策略：c1和c2一人一次。
  * 广播策略：每条消息会同时发给消费者c1和c2.

* 假设有两个消费者组同时订阅了同一个主题，消息给谁？

  * 以组为单位，每组都会给一份，至于组内的策略，可以采用轮询，也可以广播。

    

## 3.3 负载均衡

![image-20250511225915200](F:\JavaCode\MessageQueue\RocketMQ\document\image\image-20250511225915200.png)



## 3.4 代理者位点与消费者位点

![image-20250512095102597](F:\JavaCode\MessageQueue\RocketMQ\document\image\image-20250512095102597.png)

以队列0为例：

![image-20250512095237513](F:\JavaCode\MessageQueue\RocketMQ\document\image\image-20250512095237513.png)

* 消费者位点：指的就是当前将要消费的消息。如果当前消息被成功消费，消费者位点就会+1.
* 代理者位点：指的是队列中的最后一条消息。生产者向消息队列发送消息时，代理者位点+1.
* 差值：指的就是没来得及消费的消息个数。



## 3.5 消费模式

MQ的消费模式可以大致分为两种，一种是推Push，一种是拉Pull。

* push模式
  * Push是服务端【MQ】主动推送消息给客户端，优点是及时性较好，但如果客户端没有做好流控，一旦服务端推送大量消息到客户端时，就会导致客户端消息堆积甚至崩溃。**只要队列有消息，立马投递给消费者。实时性很强，导致客户端压力大**
* pull模式
  * Pull是客户端需要**主动到服务端取数据**，优点是客户端可以依据自己的消费能力进行消费，但拉取的频率也需要用户自己控制，拉取频繁容易造成服务端和客户端的压力，拉取间隔长又容易造成消费不及时。**一次性可以拿到很多消息，但是只有消费者成功消费了，mq里面才会移动消费者点位。**
* 如何选择两种模式：
  * **Push模式也是基于pull模式的**，只是客户端内部封装了api（push相当于隔一段时间pull一次，通过长轮询的方式实现的），一般场景下，上游消息生产量小或者均速的时候，选择push模式。在特殊场景下，例如电商大促，抢优惠券等场景可以选择pull模式。







# 四. 消息的发送

## 4.1 发送同步消息

上面的快速入门就是发送同步消息，发送过后会有一个返回值，也就是mq服务器接收到消息后返回的一个确认，**这种方式非常安全，但是性能上并没有这么高，而且在mq集群中，也是要等到所有的从机都复制了消息以后才会返回，所以针对重要的消息可以选择这种方式。**

![img](F:\JavaCode\MessageQueue\RocketMQ\document\image\wps1-1747016547884-1.jpg)

这里的同步是指生产者和mq主机之间的消息传输是同步的，并不是消费者消费消息是同步的。生产者发送消息给mq主机之后，需要收到mq主机的返回值才能继续向下进行，在未收到返回值之前，生产者只能等待。



## 4.2 发送异步消息

### 4.2.1 异步消息

异步消息通常用在对响应时间敏感的业务场景，即发送端不能容忍长时间地等待Broker的响应。发送完以后会有一个异步消息通知.

### 4.2.2 异步消息生产者

```java
@Test
public void asyncProducer() throws Exception{
    // 1.创建一个生产者
    DefaultMQProducer producer = new DefaultMQProducer("async-producer-group");
    // 2.连接NameServer
    producer.setNamesrvAddr("111.119.211.126:9876");
    // 3.开启生产者
    producer.start();
    // 4.创建一个消息
    Message message = new Message("asyncTopic", "我是一个异步消息".getBytes());
    // 5.发送消息 异步发送，需要设置一个回调函数
    producer.send(message, new SendCallback() {
        @Override
        public void onSuccess(SendResult sendResult) {
            // 成功时的回调
            System.out.println("发送成功");
        }

        @Override
        public void onException(Throwable throwable) {
            // 失败时的回调
            System.out.println("发送失败:" + throwable.getMessage());
        }
    });
    System.in.read();
}
```

### 4.2.3 异步消息消费者

与同步消息的消费者是相同的，参考3.2.3



## 4.3 发送单向消息

### 4.3.1 单向消息

这种方式主要用在不关心发送结果的场景，这种方式吞吐量很大，但是存在消息丢失的风险，例如日志信息的发送。

### 4.3.2 单向消息生产者

```java
@Test
public void onewayProducer() throws Exception {
    // 1. 创建一个生产者
    DefaultMQProducer producer = new DefaultMQProducer("oneway-producer-group");
    // 2. 连接NameServer
    producer.setNamesrvAddr("111.119.211.126:9876");
    // 3. 启动生产者
    producer.start();
    // 4. 创建一个消息
    Message message = new Message("onewayTopic", "我发送了一个单向消息".getBytes());
    // 5. 发送单向消息
    producer.sendOneway(message);
    // 6. 关闭生产者
    producer.shutdown();
}
```

### 4.3.3  单向消息消费者

与同步消息的消费者是相同的，参考3.2.3



## 4.4 发送延迟消息

### 4.4.1 应用场景

消息放入mq后，过一段时间，才会被监听到，然后消费

比如下订单业务，提交了一个订单就可以发送一个延时消息，30min后去检查这个订单的状态，如果还是未付款就取消订单释放库存。

### 4.4.2 延迟消息生产者

```java
@Test
public void delayProducer() throws Exception{
    // 1. 创建生产者
    DefaultMQProducer producer = new DefaultMQProducer("delay-producer-group");
    // 2. 连接NameServer
    producer.setNamesrvAddr("111.119.211.126:9876");
    // 3. 开启生产者
    producer.start();
    // 4. 创建消息
    Message message = new Message("delayTopic", "订单号，座位号".getBytes());
    // 5. 给消息设置一个延迟等级
    message.setDelayTimeLevel(3);
    // 6. 发送消息
    // 注意这里的10000不是消息的延迟时间，而是与mq服务连接的超时时间
    producer.send(message, 10000);
    // 7. 关闭生产者
    producer.shutdown();
}
```

注意：

* `messageDelayLevel ` 是Rocketmq所设置好的。对应关系如下：

  | 等级 | 1    | 2    | 3    | ...  | 17   | 18   |
  | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
  | 时间 | 1s   | 5s   | 10s  | ...  | 1h   | 2h   |

* 具体的对应关系见官网：https://rocketmq.apache.org/zh/docs/4.x/producer/04message3
* 如果想要自定义等级和延迟时间，需要在broker的配置文件中定义`messageDelayLevel`属性

### 4.4.3 延迟消息消费者

```java
@Test
public void delayConsumer() throws Exception{
    // 1. 创建消费者
    DefaultMQPushConsumer consumer = new DefaultMQPushConsumer("delay-consumer-group");
    // 2. 添加NameServer地址
    consumer.setNamesrvAddr("111.119.211.126:9876");
    // 3. 订阅主题
    consumer.subscribe("delayTopic", "*");
    // 4. 设置监听器
    consumer.registerMessageListener(new MessageListenerConcurrently() {
        @Override
        public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> list, ConsumeConcurrentlyContext context) {
            System.out.println("收到消息了" + new Date());
            System.out.println(new String(list.get(0).getBody()));
            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
        }
    });
    // 5. 启动消费者
    consumer.start();
    System.in.read();
}
```



## 4.5 发送批量消息

### 4.5.1 批量消息

Rocketmq可以一次性发送一组消息，那么这一组消息会被当做一个消息消费

### 4.5.2 批量消息生产者

```java
@Test
public void testBatchProducer() throws Exception {
    // 创建默认的生产者
    DefaultMQProducer producer = new DefaultMQProducer("batch-producer-group");
    // 设置nameServer地址
    producer.setNamesrvAddr("111.119.211.126:9876");
    // 启动生产者
    producer.start();
    // 创建一组消息
    List<Message> msgs = Arrays.asList(
        new Message("batchTopic", "我是一组消息的A消息".getBytes()),
        new Message("batchTopic", "我是一组消息的B消息".getBytes()),
        new Message("batchTopic", "我是一组消息的C消息".getBytes())
    );
    // 发送消息
    SendResult send = producer.send(msgs);
    System.out.println(send);
    // 关闭生产者
    producer.shutdown();
}
```

注意：

* 以上的三条消息被视为一组，会打包发送到同一个消息队列中。

### 4.5.3 批量消息消费者

```java
@Test
public void testBatchConsumer() throws Exception {
    // 创建默认消费者组
    DefaultMQPushConsumer consumer = new DefaultMQPushConsumer("batch-consumer-group");
    // 设置nameServer地址
    consumer.setNamesrvAddr("111.119.211.126:9876");
    // 订阅一个主题来消费   表达式，默认是*
    consumer.subscribe("batchTopic", "*");
    // 注册一个消费监听 MessageListenerConcurrently是并发消费
    // 默认是20个线程一起消费，可以参看 consumer.setConsumeThreadMax()
    consumer.registerMessageListener(new MessageListenerConcurrently() {
        @Override
        public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs, ConsumeConcurrentlyContext context) {
            // 这里执行消费的代码 默认是多线程消费
            System.out.println(Thread.currentThread().getName() + "----" + new String(msgs.get(0).getBody()));
            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
        }
    });
    consumer.start();
    System.in.read();
}
```



## 4.6 发送顺序消息

### 4.6.1 顺序消息

* 消息有序指的是可以**按照消息的发送顺序来消费**(FIFO)。RocketMQ可以严格的保证消息有序，可以分为：分区有序或者全局有序。

* rocketMq的broker的机制，导致了rocketMq会有这个问题。因为一个broker中对应了四个queue

  ![img](F:\JavaCode\MessageQueue\RocketMQ\document\image\wps2-1747025090366-3.jpg)

* 顺序消费的原理解析
  * 在默认的情况下消息发送会采取Round Robin轮询方式把消息发送到不同的queue(分区队列)；而消费消息的时候从多个queue上拉取消息，这种情况发送和消费是不能保证顺序。但是如果控制发送的顺序消息只依次发送到同一个queue中，消费的时候只从这个queue上依次拉取，则就保证了顺序。当发送和消费参与的queue只有一个，则是全局有序；如果多个queue参与，则为分区有序，即相对每个queue，消息都是有序的。
  * 注意：消费者线程也只能有一个才能保证有序（这里的一个指的是每一组消息只有一个消费者）。不能采用并发模式。



### 4.6.2 场景分析

* 下面用订单进行分区有序的示例。一个订单的顺序流程是：下订单、发短信通知、物流、签收。订单顺序号相同的消息会被先后发送到同一个队列中，消费时，同一个顺序获取到的肯定是同一个队列。
* 模拟一个订单的发送流程，创建两个订单，发送的消息分别是：
  * 订单号111 消息流程 下订单->物流->签收
  * 订单号222 消息流程 下订单->物流->拒收



### 4.6.3 订单对象

```java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Order {
    private String orderSn; //订单编号
    private Integer userId; // 用户id
    private String desc; // 描述信息
}
```



### 4.6.4 顺序消息生产者

```java
@Test
public void orderProducer() throws Exception {
    // 1.创建生产者
    DefaultMQProducer producer = new DefaultMQProducer("order-producer-group");
    // 2.连接NameServer
    producer.setNamesrvAddr("111.119.211.126:9876");
    // 3.启动生产者
    producer.start();

    // 创建订单信息
    List<Order> orders = Arrays.asList(
        new Order("111", 1, "下单"),
        new Order("111", 1, "物流"),
        new Order("111", 1, "签收"),
        new Order("222", 2, "下单"),
        new Order("222", 2, "物流"),
        new Order("222", 2, "拒收")
    );

    for (Order order : orders) {
        // 4. 创建消息
        Message message = new Message("orderTopic", order.toString().getBytes());
        // 5. 发送消息
        producer.send(message,  new MessageQueueSelector() {
            @Override
            public MessageQueue select(List<MessageQueue> list, Message message, Object arg) {
                // 这里arg就是send方法的第三个参数，即订单编号
                // 我们要在这个方法中进行选择队列，让相同的订单号去同一个消息队列中。
                int hashCode = arg.toString().hashCode();
                int index = hashCode % list.size(); // 求余数，求模 获取一个队列的下标
                return list.get(index);
            }
        }, order.getOrderSn());
    }
    System.out.println("发送消息成功");
    // 6.关闭生产者
    producer.shutdown();
}
```



### 4.6.5 顺序消息消费者

```java
@Test
public void orderConsumer() throws Exception {
    // 1. 创建一个消费者
    DefaultMQPushConsumer consumer = new DefaultMQPushConsumer("order-consumer-group");
    // 2. 连接NameServer
    consumer.setNamesrvAddr("111.119.211.126:9876");
    // 3. 订阅主题
    consumer.subscribe("orderTopic", "*");
    // 4. 设置一个监听器 (异步进行的，一直监听)
    // 这里我们不能使用 MessageListenerConcurrently，因为这个监听器是并发的，不能保证消息的顺序。
    consumer.registerMessageListener(new MessageListenerOrderly() {
        @Override
        public ConsumeOrderlyStatus consumeMessage(List<MessageExt> list, ConsumeOrderlyContext consumeOrderlyContext) {
            System.out.println("线程id:" + Thread.currentThread().getId() + ", 接收到消息：" + new String(list.get(0).getBody()));
            return ConsumeOrderlyStatus.SUCCESS;
        }
    });
    // 5. 启动消费者
    consumer.start();
    System.in.read();
}
```

* 监听器不能使用`MessageListenerConcurrently`，因为其是并发的。

* 每组消息设置了一个消费者线程，并非一共只有一个线程。

  ![image-20250512140114207](F:\JavaCode\MessageQueue\RocketMQ\document\image\image-20250512140114207.png)

  线程之间接收的顺序是可以无序的，但是同一个线程内的消息一定是顺序接收的。

* 如果接收消息失败了，会进行重试

  * 并发模式`MessageListenerConcurrently`下，会重试16次，如果仍失败，就会送到死信队列中。
  * 顺序模式`MessageListenerOrderly`下，会无限重试，重试int类型的最大值。







# 五. 消息过滤

## 5.1 标签的简介

1. 什么是标签？

   ​		topic 是消息的顶层容器，用于将消息划分为不同的业务模块或系统。不同 Topic 的消息完全隔离，适合业务逻辑差异较大的场景。Tag 是 Topic 下的 **二级分类**，用于进一步细分消息的业务属性或特征。

2. 为什么要有标签？

   ​		同一业务模块下存在多个子类，但需要统一管理。例如，`Topic_Order` 中的订单消息，可以通过 `Tag `进一步区分商品类型：`Tag_Electronics`（电子产品）、`Tag_Clothing`（服装）、`Tag_Cosmetics`（化妆品）。如果仅用 Topic，可能需要创建 `Topic_Order_Electronics`、`Topic_Order_Clothing` 等多个 Topic，导致 Topic 数量爆炸，增加管理复杂性。**Topic 数量越少，监控、维护和故障排查的复杂度越低。**

3. 例子：

   ​		某个公众号有两类会员，vip与svip，该公众号发消息到某个主题，vip只能收到vip相关的消息，而svip既可以收到vip相关消息，也可以收到svip的消息，就可以采用标签来为消息进行区分。

4. **订阅关系一致性**

   同一个消费者组中的消费者订阅的消息必须主题和标签都相同。

   发送的消息会以组为单位，每个消费者组给一份。



## 5.2 标签消息生产者

```java
@Test
public void tagProducer() throws Exception{
    // 1. 创建一个生产者
    DefaultMQProducer producer = new DefaultMQProducer("tag-producer-group");
    // 2.连接NameServer
    producer.setNamesrvAddr("111.119.211.126:9876");
    // 3. 启动生产者
    producer.start();
    // 4. 创建一个带标签tag的消息
    Message message1 = new Message("tagTopic", "vip", "我一个vip的消息".getBytes());
    Message message2 = new Message("tagTopic", "svip", "我一个svip的消息".getBytes());
    // 5. 发送消息
    producer.send(message1);
    producer.send(message2);
    System.out.println("发送完成");
    // 6. 关闭生产者
    producer.shutdown();
}
```



## 5.3 标签消息消费者

```java
@Test
public void tagConsumer() throws Exception{
    // 1. 创建消费者
    DefaultMQPushConsumer consumer1 = new DefaultMQPushConsumer("tag-consumer-group-a");
    DefaultMQPushConsumer consumer2 = new DefaultMQPushConsumer("tag-consumer-group-b");
    // 2. 连接NameServer
    consumer1.setNamesrvAddr("111.119.211.126:9876");
    consumer2.setNamesrvAddr("111.119.211.126:9876");
    // 3. 订阅主题和标签
    consumer1.subscribe("tagTopic", "vip"); //只订阅vip
    consumer2.subscribe("tagTopic", "vip || svip"); // 订阅vip和svip
    // 4. 注册监听器
    consumer1.registerMessageListener((MessageListenerConcurrently) (list, contest) -> {
        System.out.println("我是vip，我正在消费消息：" + new String(list.get(0).getBody()));
        return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
    });
    consumer2.registerMessageListener((MessageListenerConcurrently) (list, context) -> {
        System.out.println("我是svip，我正在消费消息：" + new String(list.get(0).getBody()));
        return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
    });
    // 5. 启动消费者
    consumer1.start();
    consumer2.start();
    System.in.read();
}
```



## 5.4 topic和tag的选择

​		不同的业务应该使用不同的Topic，如果是相同的业务里面有不同表的表现形式，那么我们要使用tag进行区分。

​		我们可以从以下几个方面进行判断：

* **消息类型是否一致**：如普通消息、事务消息、定时（延时）消息、顺序消息，不同的消息类型使用不同的 Topic，无法通过 Tag 进行区分。
* **业务是否相关联**：没有直接关联的消息，如淘宝交易消息，京东物流消息使用不同的 Topic 进行区分；而同样是天猫交易消息，电器类订单、女装类订单、化妆品类订单的消息可以用 Tag 进行区分。
* **消息优先级是否一致**：如同样是物流消息，盒马必须小时内送达，天猫超市 24 小时内送达，淘宝物流则相对会慢一些，不同优先级的消息用不同的 Topic 进行区分。
* **消息量级是否相当**：有些业务消息虽然量小但是实时性要求高，如果跟某些万亿量级的消息使用同一个 Topic，则有可能会因为过长的等待时间而“饿死”，此时需要将不同量级的消息进行拆分，使用不同的 Topic。

​		**总的来说，针对消息分类，您可以选择创建多个 Topic，或者在同一个 Topic 下创建多个 Tag。但通常情况下，不同的 Topic 之间的消息没有必然的联系，而 Tag 则用来区分同一个 Topic 下相互关联的消息，例如全集和子集的关系、流程先后的关系。**



## 5.5 消息中的key

### 5.5.1 简介

​		在rocketmq中的消息，默认会有一个`messageId`当做消息的唯一标识，我们也可以给消息携带一个`key`，用作唯一标识或者业务标识，包括在控制面板查询的时候也可以使用`messageId`或者`key`来进行查询。

![image-20250512170752190](F:\JavaCode\MessageQueue\RocketMQ\document\image\image-20250512170752190.png)

​		`messageId`是mq给消息生成的唯一标记。

​		我们也可以自己给消息带一个唯一标记：消息的`key`。**这个key需要我们自己保证唯一，mq是不管的。**

### 5.5.2 带key的消息生产者

```java
@Test
public void keyProducer() throws Exception {
    // 1. 创建一个生产者
    DefaultMQProducer producer = new DefaultMQProducer("key-producer-group");
    // 2.连接NameServer
    producer.setNamesrvAddr("111.119.211.126:9876");
    // 3. 启动生产者
    producer.start();
    // 4. 创建一个带标签tag和key的消息
    String key = UUID.randomUUID().toString(); // 生成消息的key
    System.out.println(key);
    Message message = new Message("keyTopic", "vip", key, "我一个vip的消息".getBytes());
    // 5. 发送消息
    producer.send(message);
    System.out.println("发送完成");
    // 6. 关闭生产者
    producer.shutdown();
}
```

### 5.5.3 带key的消息消费者

```java
@Test
public void keyConsumer() throws Exception{
    // 1. 创建消费者
    DefaultMQPushConsumer consumer = new DefaultMQPushConsumer("key-consumer-group");
    // 2. 连接NameServer
    consumer.setNamesrvAddr("111.119.211.126:9876");
    // 3. 订阅主题和标签
    consumer.subscribe("keyTopic", "vip"); //只订阅vip
    // 4. 注册监听器
    consumer.registerMessageListener((MessageListenerConcurrently) (list, contest) -> {
        System.out.println("我是vip，我正在消费消息：" + new String(list.get(0).getBody()));
        System.out.println(list.get(0).getKeys()); // 获取消息的key
        return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
    });
    // 5. 启动消费者
    consumer.start();
    System.in.read();
}
```

注意：**订阅至于主题和标签相关，与key无关**







# 六. 消息重复消费问题

## 6.1 为什么会出现重复消费问题

1. BROADCASTING(广播)模式下，所有注册的消费者都会消费，而这些消费者通常是集群部署的一个个微服务，这样就会多台机器重复消费，当然这个是根据需要来选择。
   CLUSTERING（负载均衡）模式下，如果一个topic被多个consumerGroup消费，也会重复消费。
2. 即使是在CLUSTERING（负载均衡）模式下，同一个consumerGroup下，一个队列只会分配给一个消费者，看起来好像是不会重复消费。但是，有个特殊情况：一个消费者新上线后，同组的所有消费者要重新负载均衡（反之一个消费者掉线后，也一样）。一个队列所对应的新的消费者要获取之前消费的offset（偏移量，也就是消息消费的点位），此时之前的消费者可能已经消费了一条消息，但是并没有把offset提交给broker，那么新的消费者可能会重新消费一次。虽然orderly模式是前一个消费者先解锁，后一个消费者加锁再消费的模式，比起concurrently要严格了，但是加锁的线程和提交offset的线程不是同一个，所以还是会出现极端情况下的重复消费。
3. 还有在发送批量消息的时候，会被当做一条消息进行处理，那么如果批量消息中有一条业务处理成功，其他失败了，还是会被重新消费一次。
4. 生产者多次投递：生产者给mq发消息，mq收到消息之后需要给生产者一个确认回复，如果此时生产者和mq之间的连接断开了，生产者就收不到这个确认回复，就会多次投递。
5. 那么如果在CLUSTERING（负载均衡）模式下，并且在同一个消费者组中，不希望一条消息被重复消费，改怎么办呢？我们可以想到去重操作，找到消息唯一的标识，可以是msgId也可以是你自定义的唯一的key，这样就可以去重了



## 6.2 解决方案

### 6.2.1 概述

* 使用去重方案解决，例如**将消息的唯一标识存起来，然后每次消费之前先判断是否存在这个唯一标识，如果存在则不消费，如果不存在则消费，并且消费以后将这个标记保存。**消息id是全局唯一标识，但在某些情况下，可能会存在相同的消息有两个不同的msgId的情况（消费者主动重发，因客户端重投机制导致的重复等），这种情况就需要使用业务字段进行去重处理。可以为每条消息设置一个key，在业务层面保证这个key是唯一的，例如使用mysql的主键值。

* 想法很好，但是消息的体量是非常大的，可能在生产环境中会到达上千万甚至上亿条，那么我们该如何选择一个容器来保存所有消息的标识，并且又可以快速的判断是否存在呢？

* 一些可以存放这个标记的容器

  * 内存中的map是不行的，因为机器重启之后，这些标记就没有了。此外，如果消费者在两个机器上，其内存也是不共享的。
  * redis可以
  * mysql可以

* 我们可以选择**布隆过滤器(BloomFilter)**
  		布隆过滤器（Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都比一般的算法要好的多，缺点是有一定的误识别率和删除困难。布隆过滤器判断一个元素有是可能有，无是一定无

  ​		在hutool的工具中我们可以直接使用，当然你自己使用redis的bitmap类型手写一个也是可以的 https://hutool.cn/docs/#/bloomFilter/%E6%A6%82%E8%BF%B0 

* 去重是在消费者方进行处理的。消费者需要控制消息的幂等性。所谓幂等性就是指：多次操作产生的影响均和第一次操作产生的影响相同。



### 6.2.2 

