# 一. MQ简介

## 1.1 为什么要使用MQ

* 要做到系统解耦，当新的模块进来时，可以做到代码改动最小;  **能够解耦**
* 设置流程缓冲池，可以让后端系统按自身吞吐能力进行消费，不被冲垮; **能够削峰，限流**
* 强弱依赖梳理能把非关键调用链路的操作异步化并提升整体系统的吞吐能力;**能够异步**

***Mq的作用  削峰限流 异步 解耦合***



## 1.2 定义

* 中间件是什么？
  * 中间件（缓存中间件  redis memcache  数据库中间件 mycat  canal   消息中间件mq ）
  * 面向消息的中间件(message-oriented middleware) MOM能够很好的解决以上的问题。是指利用高效可靠的消息传递机制进行与平台无关（跨平台）的数据交流，并基于数据通信来进行分布式系统的集成。

* 通过提供**消息传递和消息排队模型**在分布式环境下提供应用解耦，弹性伸缩，冗余存储，流量削峰，异步通信，数据同步等
* 大致流程
  * 发送者把消息发给消息服务器[MQ]，
  * 消息服务器把消息存放在若干**队列/主题**中
  * 在合适的时候，消息服务器会把消息转发给接受者。
* 在这个过程中，发送和接受是异步的,也就是发送无需等待，发送者和接受者的生命周期也没有必然关系在发布pub/订阅sub模式下，也可以完成一对多的通信，可以让一个消息有多个接受者[微信订阅号就是这样的]

![img](F:\JavaCode\MessageQueue\RocketMQ\document\image\wps1.jpg)

## 1.3 特点

### 1.3.1 异步处理模式

​	消息发送者可以发送一个消息而无需等待响应。消息发送者把消息发送到一条虚拟的通道(主题或队列)上;

​	消息接收者则订阅或监听该通道。一条信息可能最终转发给一个或多个消息接收者，这些接收者都无需对消息发送者做出回应。整个过程都是异步的。

​	也就是说，一个系统和另一个系统间进行通信的时候，假如系统A希望发送一个消息给系统B，让它去处理，但是系统A不关注系统B到底怎么处理或者有没有处理好，所以系统A把消息发送给MQ，然后就不管这条消息的“死活” 了，接着系统B从MQ里面消费出来处理即可。至于怎么处理，是否处理完毕，什么时候处理，都是系统B的事，与系统A无关。

![img](F:\JavaCode\MessageQueue\RocketMQ\document\image\wps2.jpg)

这样的一种通信方式，就是所谓的“异步”通信方式，对于系统A来说，只要把消息发给MQ,然后系统B就会异步处去进行处理了，系统A不能“同步”的等待系统B处理完。这样的好处是什么呢？**解耦**

### 1.3.2 应用系统的解耦

  发送者和接收者不必了解对方，只需要确认消息
  发送者和接收者不必同时在线

### 1.3.3 现实中的业务

![image-20250414151713214](F:\JavaCode\MessageQueue\RocketMQ\document\image\image-20250414151713214.png)



## 1.4 各种MQ产品的比较

![image-20250414151819771](F:\JavaCode\MessageQueue\RocketMQ\document\image\image-20250414151819771.png)

![image-20250414153450707](F:\JavaCode\MessageQueue\RocketMQ\document\image\image-20250414153450707.png)







# 二. RocketMQ基础

## 2.1 RocketMQ简介

* 官网：http://rocketmq.apache.org/

* 介绍：

  >RocketMQ是阿里巴巴2016年MQ中间件，使用Java语言开发，RocketMQ 是一款开源的**分布式消息系统**，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务。同时，广泛应用于多个领域，包括异步通信解耦、企业解决方案、金融支付、电信、电子商务、快递物流、广告营销、社交、即时通信、移动应用、手游、视频、物联网、车联网等。

* 具有以下特点：

  * 能够保证严格的消息顺序
  * 提供丰富的消息拉取模式
  * 高效的订阅者水平扩展能力
  * 实时的消息订阅机制
  * 亿级消息堆积能力



## 2.2 RocketMQ相关概念

* **Producer**：消息的发送者，生产者；举例：发件人
* **Consumer**：消息接收者，消费者；举例：收件人
* **Broker**：暂存和传输消息的通道；举例：快递
* **NameServer**：管理Broker；举例：各个快递公司的管理机构 相当于broker的注册中心，保留了broker的信息
* **Queue**：队列，消息存放的位置，**一个Broker中可以有多个队列**。【实际存放的是消息的地址，而不是消息本身】
* **Topic**：主题，消息的分类
* ProducerGroup：生产者组
* ConsumerGroup：消费者组，多个消费者组可以同时消费一个主题的消息



## 2.3 消息发送流程

消息发送的流程是，Producer询问NameServer，NameServer分配一个broker（每一个broker都还有从机），然后Consumer也要询问NameServer，得到一个具体的broker，然后消费消息。以下图是一个单机版的RocketMQ。

![img](F:\JavaCode\MessageQueue\RocketMQ\document\image\wps1-1746870218860-1.jpg)



## 2.4 生产和消费的理解

![img](F:\JavaCode\MessageQueue\RocketMQ\document\image\wps2-1746871954103-3.jpg)

## 2.5 安装

### 2.5.1 下载RocketMQ

* 下载地址：https://rocketmq.apache.org/zh/download

* 注意选择版本，这里我们选择4.9.2的版本，与后面使用alibaba时对应

  ![image-20250510191403080](F:\JavaCode\MessageQueue\RocketMQ\document\image\image-20250510191403080.png)

  下载bin文件



### 2.5.2 下载RocketMQ控制台

* Rocketmq 控制台可以可视化MQ的消息发送！
* 网址：https://rocketmq.apache.org/zh/docs/deploymentOperations/04Dashboard/



### 2.5.3 上传服务器

* 在root目录下新建文件夹

  ```
  mkdir rocketmq
  ```

* 将bin文件的压缩包和控制台的jar包上传上去

  ![image-20250510195533529](F:\JavaCode\MessageQueue\RocketMQ\document\image\image-20250510195533529.png)



### 2.5.4 解压

```
unzip rocketmq-all-4.9.2-bin-release.zip
```

如果你的服务器没有unzip命令，则下载安装一个

```
yum install unzip
```

目录分析：

![image-20250510195610685](F:\JavaCode\MessageQueue\RocketMQ\document\image\image-20250510195610685.png)

* Benchmark：包含一些性能测试的脚本；
* Bin：可执行文件目录；
* Conf：配置文件目录；
* Lib：第三方依赖；
* LICENSE：授权信息;
* NOTICE：版本公告；



### 2.5.5 配置环境变量

```
vim /etc/profile
```

在文件末尾添加

```
export NAMESRV_ADDR=阿里云公网IP:9876
```

刷新环境变量

```
source /etc/profile
```



### 2.5.6 修改nameServer的运行脚本

进入bin目录下，修改runserver.sh文件,将71行和76行的Xms和Xmx以及Xmn等改小一点

```
vim runserver.sh
```

![image-20250510200756427](F:\JavaCode\MessageQueue\RocketMQ\document\image\image-20250510200756427.png)



### 2.5.7 修改broker的运行脚本

进入bin目录下，修改runbroker.sh文件,修改67行

```
vim runbroker.sh
```

![image-20250510201051789](F:\JavaCode\MessageQueue\RocketMQ\document\image\image-20250510201051789.png)



### 2.5.8 修改broker的配置文件

进入conf目录下，修改broker.conf文件

```
brokerClusterName = DefaultCluster
brokerName = broker-a
brokerId = 0
deleteWhen = 04
fileReservedTime = 48
brokerRole = ASYNC_MASTER
flushDiskType = ASYNC_FLUSH
namesrvAddr=111.119.211.126:9876
autoCreateTopicEnable=true
brokerIP1=阿里云公网IP
```

* namesrvAddr：nameSrv的地址，可以写localhost，因为nameSrv和broker在一个服务器上。
* autoCreateTopicEnable：自动创建主题，不然需要手动创建出来
* brokerIP1：broker也需要一个公网ip，如果不指定，那么是阿里云的内网地址，我们再本地无法连接使用



### 2.5.9 启动nameserver和broker

* 首先在安装目录下创建一个logs文件夹，用于存放日志

  ```
  mkdir logs
  ```

  ![image-20250510210658229](F:\JavaCode\MessageQueue\RocketMQ\document\image\image-20250510210658229.png)

* 在bin目录下执行：

  * 启动nameserver

    ```
    # nohup表示在后台运行，不占用控制台
    # 执行mqnamesrv脚本文件，输出日志到namesrv.log文件中
    nohup sh mqnamesrv > ../logs/namesrv.log &
    ```

  * 启动broker

    ```
    # 这里的-c是指定使用的配置文件
    nohup sh mqbroker -c ../conf/broker.conf > ../logs/broker.log &
    ```

* 可以使用`jps -l`命令查看java应用的进程号

  ![image-20250510211326726](F:\JavaCode\MessageQueue\RocketMQ\document\image\image-20250510211326726.png)

  

### 2.5.10 启动RocketMQ控制台

```
nohup java -jar ./rocketmq-dashboard-1.0.0.jar --server.port=8001 --rocketmq.config.namesrvAddr=127.0.0.1:9876 > ./rocketmq-4.9.2/logs/dashboard.log &
```

* `--server.port=8001` : 指定端口号，默认是8080.
* `--rocketmq.config.namesrvAddr=127.0.0.1:9876`：指定namesrv地址。

![image-20250510212106851](F:\JavaCode\MessageQueue\RocketMQ\document\image\image-20250510212106851.png)

**注意要在安全组策略中放开9876和10100-11000端口。**



## 2.6 Docker部署RocketMQ

### 2.6.1 下载镜像

```
docker pull apache/rocketmq:4.9.2 # rocketmq镜像
docker pull apacherocketmq/rocketmq-dashboard:1.0.0 # 控制台镜像
```

### 2.6.2 创建容器共享网络

RocketMQ中有多个服务，需要创建多个容器，创建 docker 网络便于容器间相互通信。

```
docker network create rocketmq
```

### 2.6.3 启动NameServer

* 创建NameServer数据存储路径

  ```
  mkdir -p /root/rocketmq/data/namesrv/logs /root/rocketmq/data/namesrv/store
  ```

* 启动NameServer容器

  ```
  docker run -d --name rmqnamesrv -p 9876:9876 \
  -v /root/rocketmq/data/namesrv/logs:/root/logs \
  -v /root/rocketmq/data/namesrv/store:/root/store \
  -e "MAX_POSSIBLE_HEAP=100000000" \
  --net rocketmq \
  apache/rocketmq:4.9.2 sh mqnamesrv
  ```

* 查看是否启动成功

  ```
  docker logs -f rmqnamesrv # rmqnamesrv是容器的名字
  ```

### 2.6.4 启动Broker

* 创建Broker数据存储路径

  ```
  mkdir -p /root/rocketmq/data/broker/logs /root/rocketmq/data/broker/store
  ```

* 创建conf配置文件目录

  ```
  mkdir /root/rocketmq/conf
  ```

* 在配置文件目录下新建broker.conf配置文件，内容如下

  ```
  # 所属集群名称，如果节点较多可以配置多个
  brokerClusterName = DefaultCluster
  #broker名称，master和slave使用相同的名称，表明他们的主从关系
  brokerName = broker-a
  #0表示Master，大于0表示不同的slave
  brokerId = 0
  #表示几点做消息删除动作，默认是凌晨4点
  deleteWhen = 04
  #在磁盘上保留消息的时长，单位是小时
  fileReservedTime = 48
  #有三个值：SYNC_MASTER，ASYNC_MASTER，SLAVE；同步和异步表示Master和Slave之间同步数据的机制；
  brokerRole = ASYNC_MASTER
  #刷盘策略，取值为：ASYNC_FLUSH，SYNC_FLUSH表示同步刷盘和异步刷盘；SYNC_FLUSH消息写入磁盘后才返回成功状态，ASYNC_FLUSH不需要；
  flushDiskType = ASYNC_FLUSH
  # 设置broker节点所在服务器的ip地址
  brokerIP1 = 111.119.211.126
  ```

* 启动Broker容器

  ```
  docker run -d  --name rmqbroker \
  --link rmqnamesrv:namesrv \
  --net rocketmq \
  -p 10911:10911 -p 10909:10909 \
  -v /root/rocketmq/data/broker/logs:/root/logs \
  -v /root/rocketmq/data/broker/store:/root/store \
  -v /root/rocketmq/conf/broker.conf:/opt/rocketmq-4.9.2/conf/broker.conf \
  --privileged=true \
  -e "NAMESRV_ADDR=namesrv:9876" \
  -e "MAX_POSSIBLE_HEAP=200000000" \
  apache/rocketmq:4.9.2 \
  sh mqbroker -c /opt/rocketmq-4.9.2/conf/broker.conf
  ```

  * `--link rmqnamesrv:namesrv`：将当前容器链接到名为 `rmqnamesrv` 的另一个容器，并使用别名 `namesrv`。
  * 10911端口：主要负责处理客户端与 Broker 之间的消息收发请求。
  * 10909端口：用于 Broker 高可用部署时的数据同步，确保消息的可靠性和服务的连续性。
  * `--privileged=true`：给予容器扩展权限
  * `-e "NAMESRV_ADDR=namesrv:9876"`: 设置环境变量 `NAMESRV_ADDR`，告诉 Broker Name Server 的地址，以便与之通信。
  * `-e "MAX_POSSIBLE_HEAP=200000000"`: 设置 JVM 最大可能堆内存大小为 200,000,000 字节。
  * `sh mqbroker -c /opt/rocketmq-4.9.2/conf/broker.conf`：在容器启动时执行的命令，这里是指定使用配置文件 `/opt/rocketmq-4.4.0/conf/broker.conf` 来启动 Broker。

* 验证broker是否启动成功

  ```
  docker logs rmqbroker
  ```

### 2.6.5 启动控制台

```
docker run -d --name rmqadmin \
-e "JAVA_OPTS=-Drocketmq.namesrv.addr=111.119.211.126:9876 \
-Dcom.rocketmq.sendMessageWithVIPChannel=false \
-Duser.timezone='Asia/Shanghai'" \
-v /etc/localtime:/etc/localtime \
-p 8081:8080 \
apacherocketmq/rocketmq-dashboard:1.0.0
```

* `-Dcom.rocketmq.sendMessageWithVIPChannel=false`：关闭 VIP Channel 模式。VIP Channel 是 RocketMQ 早期版本中的一种通信方式，默认监听在 Broker 的 `10912` 端口，现在基本不用了。
* `-Duser.timezone='Asia/Shanghai'"`：设置时区为中国标准时间（UTC+8）。

### 2.6.6 访问控制台

![image-20250511170033315](F:\JavaCode\MessageQueue\RocketMQ\document\image\image-20250511170033315.png)





# 三. RocketMQ快速入门

## 3.1 消息发送和监听的流程

### 3.1.1 消息生产者

1. 创建消息生产者producer，并制定生产者组名

2. 指定Nameserver地址

3. 启动producer

4. 创建消息对象，指定主题Topic、Tag和消息体等

5. 发送消息

6. 关闭生产者producer

### 3.1.2 消息消费者

1. 创建消费者consumer，制定消费者组名

2. 指定Nameserver地址

3. 创建监听订阅主题Topic和Tag等

4. 处理消息

5. 启动消费者consumer



## 3.2 搭建项目Rocketmq-demo

### 3.2.1 加入依赖

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>

<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
    <optional>true</optional>
</dependency>

<!--rocketmq原生api-->
<dependency>
    <groupId>org.apache.rocketmq</groupId>
    <artifactId>rocketmq-client</artifactId>
    <version>4.9.2</version>
</dependency>
```

### 3.2.2 编写生产者

```java
@Test
void sendMessage() throws Exception {
    // 1. 创建一个生产者 （指定一个组名：test-producer-group）
    // DefaultMQProducer producer2 = new DefaultMQProducer("test-producer-group"); 可以为一个组创建多个生产者
    DefaultMQProducer producer = new DefaultMQProducer("test-producer-group");
    // 2. 连接NameServer
    producer.setNamesrvAddr("111.119.211.126:9876");
    // 3. 启动生产者
    producer.start();
    // 4. 创建一个消息
    //    这里用的是重载的方法，指定消息主题和内容
    Message message = new Message("testTopic", "我是一个消息".getBytes());
    // 5. 发送消息
    SendResult sendResult = producer.send(message);
    System.out.println(sendResult);
    // 6. 关闭生产者
    producer.shutdown();
}
```

创建消息的消息原型：

```
// Message(String topic, String tags, String keys, int flag, byte[] body, boolean waitStoreMsgOK)
// topic：消息所属的Topic，需要提前在NameServer创建 或者在broker.conf中配置了自动创建Topic1·1· 
// tags：消息的标签，可以理解为消息的分类
// keys：消息的Key，用于消息去重
// flag：消息的标识，用于消息去重
// body：消息的内容
// waitStoreMsgOK：是否等待消息存储到NameServer
```

* 生产者为什么要设置组名？

  >没有特殊意义。同一个生产者组的生产者，可以向多个不同的主题中发送消息。



### 3.2.3 编写消费者

```java
@Test
void consumer() throws Exception{
    // 1. 创建一个消费者 (指定一个组名：test-consumer-group)
    DefaultMQPushConsumer consumer = new DefaultMQPushConsumer("test-consumer-group");
    // DefaultMQPushConsumer consumer2 = new DefaultMQPushConsumer("test-consumer-group"); // 同一个
    // 2. 连接NameServer
    consumer.setNamesrvAddr("111.119.211.126:9876");
    // 3. 订阅主题
    //    testTopic：订阅的主题名称,  *：表示订阅所有标签(所有消息)
    consumer.subscribe("testTopic", "*");
    // 4. 设置一个监听器 (异步进行的，一直监听)
    consumer.registerMessageListener(new MessageListenerConcurrently() {
        /**
         * 消费消息 这个方法会启动一个新的线程执行，
         * @param list 消息列表
         * @param context 并发消息的上下文
         * @return
         */
        @Override
        public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> list, ConsumeConcurrentlyContext context) {
            // 这个就是消费的方法
            MessageExt messageExt = list.get(0);
            System.out.println(messageExt);
            System.out.println(new String(messageExt.getBody())); // 消息内容
            System.out.println(context);
            // 返回值是ConsumeConcurrentlyStatus,是一个枚举类型
            // 该枚举类型有两个值: CONSUME_SUCCESS, RECONSUME_LATER;
            // CONSUME_SUCCESS表示成功，消息会从mq中出队
            // RECONSUME_LATER表示失败，消息会重新入队,过一会会重新投递
            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS; // 消费成功
        }
    });
    // 5. 启动消费者
    consumer.start();

    // 6.挂起当前的jvm
    System.in.read();
}
```

![image-20250511224121716](F:\JavaCode\MessageQueue\RocketMQ\document\image\image-20250511224121716.png)

* 消费者为什么要设置组名？

  > **消费者组内的消费者订阅关系必须保持一致。**即同一个消费者组的消费者只能消费同一个主题的消息。

* 假设生产者向testTopic主题中发送了一条消息，消费者组中有两个消费者c1和c2，那么这条消息到底给谁？有两种策略:

  * 轮询策略：c1和c2一人一次。
  * 广播策略：每条消息会同时发给消费者c1和c2.

* 假设有两个消费者组同时订阅了同一个主题，消息给谁？

  * 以组为单位，每组都会给一份，至于组内的策略，可以采用轮询，也可以广播。

    

## 3.3 负载均衡

![image-20250511225915200](F:\JavaCode\MessageQueue\RocketMQ\document\image\image-20250511225915200.png)



## 3.4 代理者位点与消费者位点

![image-20250512095102597](F:\JavaCode\MessageQueue\RocketMQ\document\image\image-20250512095102597.png)

以队列0为例：

![image-20250512095237513](F:\JavaCode\MessageQueue\RocketMQ\document\image\image-20250512095237513.png)

* 消费者位点：指的就是当前将要消费的消息。如果当前消息被成功消费，消费者位点就会+1.
* 代理者位点：指的是队列中的最后一条消息。生产者向消息队列发送消息时，代理者位点+1.
* 差值：指的就是没来得及消费的消息个数。



## 3.5 消费模式

​		此处的“消费模式”可能被理解为 **消费者行为模式**，即消费者与消息队列的交互方式，关注的是消费者与Broker的交互方式。通常包括以下两种实现形式（非核心消费模式，而是客户端实现方式）：

MQ的消费模式可以大致分为两种，一种是推Push，一种是拉Pull。

* push模式
  * Push是服务端【MQ】中的broker主动推送消息给客户端，优点是及时性较好，但如果客户端没有做好流控，一旦服务端推送大量消息到客户端时，就会导致客户端消息堆积甚至崩溃。**只要队列有消息，立马投递给消费者。实时性很强，导致客户端压力大**
* pull模式
  * Pull是客户端需要**主动到服务端取数据**，优点是客户端可以依据自己的消费能力进行消费，但拉取的频率也需要用户自己控制，拉取频繁容易造成服务端和客户端的压力，拉取间隔长又容易造成消费不及时。**一次性可以拿到很多消息，但是只有消费者成功消费了，mq里面才会移动消费者点位。**
* 如何选择两种模式：
  * **Push模式也是基于pull模式的**，只是客户端内部封装了api（push相当于隔一段时间pull一次，通过长轮询的方式实现的），一般场景下，上游消息生产量小或者均速的时候，选择push模式。在特殊场景下，例如电商大促，抢优惠券等场景可以选择pull模式。
  * 即处理实时消息，选择push模式，处理批量任务选择pull模式。







# 四. 消息的发送

## 4.1 发送同步消息

上面的快速入门就是发送同步消息，发送过后会有一个返回值，也就是mq服务器接收到消息后返回的一个确认，**这种方式非常安全，但是性能上并没有这么高，而且在mq集群中，也是要等到所有的从机都复制了消息以后才会返回，所以针对重要的消息可以选择这种方式。**

![img](F:\JavaCode\MessageQueue\RocketMQ\document\image\wps1-1747016547884-1.jpg)

这里的同步是指生产者和mq主机之间的消息传输是同步的，并不是消费者消费消息是同步的。生产者发送消息给mq主机之后，需要收到mq主机的返回值才能继续向下进行，在未收到返回值之前，生产者只能等待。



## 4.2 发送异步消息

### 4.2.1 异步消息

异步消息通常用在对响应时间敏感的业务场景，即发送端不能容忍长时间地等待Broker的响应。发送完以后会有一个异步消息通知.

### 4.2.2 异步消息生产者

```java
@Test
public void asyncProducer() throws Exception{
    // 1.创建一个生产者
    DefaultMQProducer producer = new DefaultMQProducer("async-producer-group");
    // 2.连接NameServer
    producer.setNamesrvAddr("111.119.211.126:9876");
    // 3.开启生产者
    producer.start();
    // 4.创建一个消息
    Message message = new Message("asyncTopic", "我是一个异步消息".getBytes());
    // 5.发送消息 异步发送，需要设置一个回调函数
    producer.send(message, new SendCallback() {
        @Override
        public void onSuccess(SendResult sendResult) {
            // 成功时的回调
            System.out.println("发送成功");
        }

        @Override
        public void onException(Throwable throwable) {
            // 失败时的回调
            System.out.println("发送失败:" + throwable.getMessage());
        }
    });
    System.in.read();
}
```

### 4.2.3 异步消息消费者

与同步消息的消费者是相同的，参考3.2.3



## 4.3 发送单向消息

### 4.3.1 单向消息

这种方式主要用在不关心发送结果的场景，这种方式吞吐量很大，但是存在消息丢失的风险，例如日志信息的发送。

### 4.3.2 单向消息生产者

```java
@Test
public void onewayProducer() throws Exception {
    // 1. 创建一个生产者
    DefaultMQProducer producer = new DefaultMQProducer("oneway-producer-group");
    // 2. 连接NameServer
    producer.setNamesrvAddr("111.119.211.126:9876");
    // 3. 启动生产者
    producer.start();
    // 4. 创建一个消息
    Message message = new Message("onewayTopic", "我发送了一个单向消息".getBytes());
    // 5. 发送单向消息
    producer.sendOneway(message);
    // 6. 关闭生产者
    producer.shutdown();
}
```

### 4.3.3  单向消息消费者

与同步消息的消费者是相同的，参考3.2.3



## 4.4 发送延迟消息

### 4.4.1 应用场景

消息放入mq后，过一段时间，才会被监听到，然后消费

比如下订单业务，提交了一个订单就可以发送一个延时消息，30min后去检查这个订单的状态，如果还是未付款就取消订单释放库存。

### 4.4.2 延迟消息生产者

```java
@Test
public void delayProducer() throws Exception{
    // 1. 创建生产者
    DefaultMQProducer producer = new DefaultMQProducer("delay-producer-group");
    // 2. 连接NameServer
    producer.setNamesrvAddr("111.119.211.126:9876");
    // 3. 开启生产者
    producer.start();
    // 4. 创建消息
    Message message = new Message("delayTopic", "订单号，座位号".getBytes());
    // 5. 给消息设置一个延迟等级
    message.setDelayTimeLevel(3);
    // 6. 发送消息
    // 注意这里的10000不是消息的延迟时间，而是与mq服务连接的超时时间
    producer.send(message, 10000);
    // 7. 关闭生产者
    producer.shutdown();
}
```

注意：

* `messageDelayLevel ` 是Rocketmq所设置好的。对应关系如下：

  | 等级 | 1    | 2    | 3    | ...  | 17   | 18   |
  | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
  | 时间 | 1s   | 5s   | 10s  | ...  | 1h   | 2h   |

* 具体的对应关系见官网：https://rocketmq.apache.org/zh/docs/4.x/producer/04message3
* 如果想要自定义等级和延迟时间，需要在broker的配置文件中定义`messageDelayLevel`属性

### 4.4.3 延迟消息消费者

```java
@Test
public void delayConsumer() throws Exception{
    // 1. 创建消费者
    DefaultMQPushConsumer consumer = new DefaultMQPushConsumer("delay-consumer-group");
    // 2. 添加NameServer地址
    consumer.setNamesrvAddr("111.119.211.126:9876");
    // 3. 订阅主题
    consumer.subscribe("delayTopic", "*");
    // 4. 设置监听器
    consumer.registerMessageListener(new MessageListenerConcurrently() {
        @Override
        public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> list, ConsumeConcurrentlyContext context) {
            System.out.println("收到消息了" + new Date());
            System.out.println(new String(list.get(0).getBody()));
            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
        }
    });
    // 5. 启动消费者
    consumer.start();
    System.in.read();
}
```



## 4.5 发送批量消息

### 4.5.1 批量消息

Rocketmq可以一次性发送一组消息，那么这一组消息会被当做一个消息消费

### 4.5.2 批量消息生产者

```java
@Test
public void testBatchProducer() throws Exception {
    // 创建默认的生产者
    DefaultMQProducer producer = new DefaultMQProducer("batch-producer-group");
    // 设置nameServer地址
    producer.setNamesrvAddr("111.119.211.126:9876");
    // 启动生产者
    producer.start();
    // 创建一组消息
    List<Message> msgs = Arrays.asList(
        new Message("batchTopic", "我是一组消息的A消息".getBytes()),
        new Message("batchTopic", "我是一组消息的B消息".getBytes()),
        new Message("batchTopic", "我是一组消息的C消息".getBytes())
    );
    // 发送消息
    SendResult send = producer.send(msgs);
    System.out.println(send);
    // 关闭生产者
    producer.shutdown();
}
```

注意：

* 以上的三条消息被视为一组，会打包发送到同一个消息队列中。

### 4.5.3 批量消息消费者

```java
@Test
public void testBatchConsumer() throws Exception {
    // 创建默认消费者组
    DefaultMQPushConsumer consumer = new DefaultMQPushConsumer("batch-consumer-group");
    // 设置nameServer地址
    consumer.setNamesrvAddr("111.119.211.126:9876");
    // 订阅一个主题来消费   表达式，默认是*
    consumer.subscribe("batchTopic", "*");
    // 注册一个消费监听 MessageListenerConcurrently是并发消费
    // 默认是20个线程一起消费，可以参看 consumer.setConsumeThreadMax()
    consumer.registerMessageListener(new MessageListenerConcurrently() {
        @Override
        public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs, ConsumeConcurrentlyContext context) {
            // 这里执行消费的代码 默认是多线程消费
            System.out.println(Thread.currentThread().getName() + "----" + new String(msgs.get(0).getBody()));
            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
        }
    });
    consumer.start();
    System.in.read();
}
```



## 4.6 发送顺序消息

### 4.6.1 顺序消息

* 消息有序指的是可以**按照消息的发送顺序来消费**(FIFO)。RocketMQ可以严格的保证消息有序，可以分为：分区有序或者全局有序。

* rocketMq的broker的机制，导致了rocketMq会有这个问题。因为一个broker中对应了四个queue

  ![img](F:\JavaCode\MessageQueue\RocketMQ\document\image\wps2-1747025090366-3.jpg)

* 顺序消费的原理解析
  * 在默认的情况下消息发送会采取Round Robin轮询方式把消息发送到不同的queue(分区队列)；而消费消息的时候从多个queue上拉取消息，这种情况发送和消费是不能保证顺序。但是如果控制发送的顺序消息只依次发送到同一个queue中，消费的时候只从这个queue上依次拉取，则就保证了顺序。当发送和消费参与的queue只有一个，则是全局有序；如果多个queue参与，则为分区有序，即相对每个queue，消息都是有序的。
  * 注意：消费者线程也只能有一个才能保证有序（这里的一个指的是每一组消息只有一个消费者）。不能采用并发模式。



### 4.6.2 场景分析

* 下面用订单进行分区有序的示例。一个订单的顺序流程是：下订单、发短信通知、物流、签收。订单顺序号相同的消息会被先后发送到同一个队列中，消费时，同一个顺序获取到的肯定是同一个队列。
* 模拟一个订单的发送流程，创建两个订单，发送的消息分别是：
  * 订单号111 消息流程 下订单->物流->签收
  * 订单号222 消息流程 下订单->物流->拒收



### 4.6.3 订单对象

```java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Order {
    private String orderSn; //订单编号
    private Integer userId; // 用户id
    private String desc; // 描述信息
}
```



### 4.6.4 顺序消息生产者

```java
@Test
public void orderProducer() throws Exception {
    // 1.创建生产者
    DefaultMQProducer producer = new DefaultMQProducer("order-producer-group");
    // 2.连接NameServer
    producer.setNamesrvAddr("111.119.211.126:9876");
    // 3.启动生产者
    producer.start();

    // 创建订单信息
    List<Order> orders = Arrays.asList(
        new Order("111", 1, "下单"),
        new Order("111", 1, "物流"),
        new Order("111", 1, "签收"),
        new Order("222", 2, "下单"),
        new Order("222", 2, "物流"),
        new Order("222", 2, "拒收")
    );

    for (Order order : orders) {
        // 4. 创建消息
        Message message = new Message("orderTopic", order.toString().getBytes());
        // 5. 发送消息
        producer.send(message,  new MessageQueueSelector() {
            @Override
            public MessageQueue select(List<MessageQueue> list, Message message, Object arg) {
                // 这里arg就是send方法的第三个参数，即订单编号
                // 我们要在这个方法中进行选择队列，让相同的订单号去同一个消息队列中。
                int hashCode = arg.toString().hashCode();
                int index = hashCode % list.size(); // 求余数，求模 获取一个队列的下标
                return list.get(index);
            }
        }, order.getOrderSn());
    }
    System.out.println("发送消息成功");
    // 6.关闭生产者
    producer.shutdown();
}
```



### 4.6.5 顺序消息消费者

```java
@Test
public void orderConsumer() throws Exception {
    // 1. 创建一个消费者
    DefaultMQPushConsumer consumer = new DefaultMQPushConsumer("order-consumer-group");
    // 2. 连接NameServer
    consumer.setNamesrvAddr("111.119.211.126:9876");
    // 3. 订阅主题
    consumer.subscribe("orderTopic", "*");
    // 4. 设置一个监听器 (异步进行的，一直监听)
    // 这里我们不能使用 MessageListenerConcurrently，因为这个监听器是并发的，不能保证消息的顺序。
    consumer.registerMessageListener(new MessageListenerOrderly() {
        @Override
        public ConsumeOrderlyStatus consumeMessage(List<MessageExt> list, ConsumeOrderlyContext consumeOrderlyContext) {
            System.out.println("线程id:" + Thread.currentThread().getId() + ", 接收到消息：" + new String(list.get(0).getBody()));
            return ConsumeOrderlyStatus.SUCCESS;
        }
    });
    // 5. 启动消费者
    consumer.start();
    System.in.read();
}
```

* 监听器不能使用`MessageListenerConcurrently`，因为其是并发的。

* 每组消息设置了一个消费者线程，并非一共只有一个线程。

  ![image-20250512140114207](F:\JavaCode\MessageQueue\RocketMQ\document\image\image-20250512140114207.png)

  线程之间接收的顺序是可以无序的，但是同一个线程内的消息一定是顺序接收的。

* 如果接收消息失败了，会进行重试

  * 并发模式`MessageListenerConcurrently`下，会重试16次，如果仍失败，就会送到死信队列中。
  * 顺序模式`MessageListenerOrderly`下，会无限重试，重试int类型的最大值。







# 五. 消息过滤

## 5.1 标签的简介

1. 什么是标签？

   ​		topic 是消息的顶层容器，用于将消息划分为不同的业务模块或系统。不同 Topic 的消息完全隔离，适合业务逻辑差异较大的场景。Tag 是 Topic 下的 **二级分类**，用于进一步细分消息的业务属性或特征。

2. 为什么要有标签？

   ​		同一业务模块下存在多个子类，但需要统一管理。例如，`Topic_Order` 中的订单消息，可以通过 `Tag `进一步区分商品类型：`Tag_Electronics`（电子产品）、`Tag_Clothing`（服装）、`Tag_Cosmetics`（化妆品）。如果仅用 Topic，可能需要创建 `Topic_Order_Electronics`、`Topic_Order_Clothing` 等多个 Topic，导致 Topic 数量爆炸，增加管理复杂性。**Topic 数量越少，监控、维护和故障排查的复杂度越低。**

3. 例子：

   ​		某个公众号有两类会员，vip与svip，该公众号发消息到某个主题，vip只能收到vip相关的消息，而svip既可以收到vip相关消息，也可以收到svip的消息，就可以采用标签来为消息进行区分。

4. **订阅关系一致性**

   同一个消费者组中的消费者订阅的消息必须主题和标签都相同。

   发送的消息会以组为单位，每个消费者组给一份。



## 5.2 标签消息生产者

```java
@Test
public void tagProducer() throws Exception{
    // 1. 创建一个生产者
    DefaultMQProducer producer = new DefaultMQProducer("tag-producer-group");
    // 2.连接NameServer
    producer.setNamesrvAddr("111.119.211.126:9876");
    // 3. 启动生产者
    producer.start();
    // 4. 创建一个带标签tag的消息
    Message message1 = new Message("tagTopic", "vip", "我一个vip的消息".getBytes());
    Message message2 = new Message("tagTopic", "svip", "我一个svip的消息".getBytes());
    // 5. 发送消息
    producer.send(message1);
    producer.send(message2);
    System.out.println("发送完成");
    // 6. 关闭生产者
    producer.shutdown();
}
```



## 5.3 标签消息消费者

```java
@Test
public void tagConsumer() throws Exception{
    // 1. 创建消费者
    DefaultMQPushConsumer consumer1 = new DefaultMQPushConsumer("tag-consumer-group-a");
    DefaultMQPushConsumer consumer2 = new DefaultMQPushConsumer("tag-consumer-group-b");
    // 2. 连接NameServer
    consumer1.setNamesrvAddr("111.119.211.126:9876");
    consumer2.setNamesrvAddr("111.119.211.126:9876");
    // 3. 订阅主题和标签
    consumer1.subscribe("tagTopic", "vip"); //只订阅vip
    consumer2.subscribe("tagTopic", "vip || svip"); // 订阅vip和svip
    // 4. 注册监听器
    consumer1.registerMessageListener((MessageListenerConcurrently) (list, contest) -> {
        System.out.println("我是vip，我正在消费消息：" + new String(list.get(0).getBody()));
        return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
    });
    consumer2.registerMessageListener((MessageListenerConcurrently) (list, context) -> {
        System.out.println("我是svip，我正在消费消息：" + new String(list.get(0).getBody()));
        return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
    });
    // 5. 启动消费者
    consumer1.start();
    consumer2.start();
    System.in.read();
}
```



## 5.4 topic和tag的选择

​		不同的业务应该使用不同的Topic，如果是相同的业务里面有不同表的表现形式，那么我们要使用tag进行区分。

​		我们可以从以下几个方面进行判断：

* **消息类型是否一致**：如普通消息、事务消息、定时（延时）消息、顺序消息，不同的消息类型使用不同的 Topic，无法通过 Tag 进行区分。
* **业务是否相关联**：没有直接关联的消息，如淘宝交易消息，京东物流消息使用不同的 Topic 进行区分；而同样是天猫交易消息，电器类订单、女装类订单、化妆品类订单的消息可以用 Tag 进行区分。
* **消息优先级是否一致**：如同样是物流消息，盒马必须小时内送达，天猫超市 24 小时内送达，淘宝物流则相对会慢一些，不同优先级的消息用不同的 Topic 进行区分。
* **消息量级是否相当**：有些业务消息虽然量小但是实时性要求高，如果跟某些万亿量级的消息使用同一个 Topic，则有可能会因为过长的等待时间而“饿死”，此时需要将不同量级的消息进行拆分，使用不同的 Topic。

​		**总的来说，针对消息分类，您可以选择创建多个 Topic，或者在同一个 Topic 下创建多个 Tag。但通常情况下，不同的 Topic 之间的消息没有必然的联系，而 Tag 则用来区分同一个 Topic 下相互关联的消息，例如全集和子集的关系、流程先后的关系。**



## 5.5 消息中的key

### 5.5.1 简介

​		在rocketmq中的消息，默认会有一个`messageId`当做消息的唯一标识，我们也可以给消息携带一个`key`，用作唯一标识或者业务标识，包括在控制面板查询的时候也可以使用`messageId`或者`key`来进行查询。

![image-20250512170752190](F:\JavaCode\MessageQueue\RocketMQ\document\image\image-20250512170752190.png)

​		`messageId`是mq给消息生成的唯一标记。

​		我们也可以自己给消息带一个唯一标记：消息的`key`。**这个key需要我们自己保证唯一，mq是不管的。**

### 5.5.2 带key的消息生产者

```java
@Test
public void keyProducer() throws Exception {
    // 1. 创建一个生产者
    DefaultMQProducer producer = new DefaultMQProducer("key-producer-group");
    // 2.连接NameServer
    producer.setNamesrvAddr("111.119.211.126:9876");
    // 3. 启动生产者
    producer.start();
    // 4. 创建一个带标签tag和key的消息
    String key = UUID.randomUUID().toString(); // 生成消息的key
    System.out.println(key);
    Message message = new Message("keyTopic", "vip", key, "我一个vip的消息".getBytes());
    // 5. 发送消息
    producer.send(message);
    System.out.println("发送完成");
    // 6. 关闭生产者
    producer.shutdown();
}
```

### 5.5.3 带key的消息消费者

```java
@Test
public void keyConsumer() throws Exception{
    // 1. 创建消费者
    DefaultMQPushConsumer consumer = new DefaultMQPushConsumer("key-consumer-group");
    // 2. 连接NameServer
    consumer.setNamesrvAddr("111.119.211.126:9876");
    // 3. 订阅主题和标签
    consumer.subscribe("keyTopic", "vip"); //只订阅vip
    // 4. 注册监听器
    consumer.registerMessageListener((MessageListenerConcurrently) (list, contest) -> {
        System.out.println("我是vip，我正在消费消息：" + new String(list.get(0).getBody()));
        System.out.println(list.get(0).getKeys()); // 获取消息的key
        return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
    });
    // 5. 启动消费者
    consumer.start();
    System.in.read();
}
```

注意：**订阅至于主题和标签相关，与key无关**







# 六. 消息重复消费问题

## 6.1 为什么会出现重复消费问题

1. BROADCASTING(广播)模式下，所有注册的消费者都会消费，而这些消费者通常是集群部署的一个个微服务，这样就会多台机器重复消费，当然这个是根据需要来选择。
   CLUSTERING（负载均衡）模式下，如果一个topic被多个consumerGroup消费，也会重复消费。
2. 即使是在CLUSTERING（负载均衡）模式下，同一个consumerGroup下，一个队列只会分配给一个消费者，看起来好像是不会重复消费。但是，有个特殊情况：一个消费者新上线后，同组的所有消费者要重新负载均衡（反之一个消费者掉线后，也一样）。一个队列所对应的新的消费者要获取之前消费的offset（偏移量，也就是消息消费的点位），此时之前的消费者可能已经消费了一条消息，但是并没有把offset提交给broker，那么新的消费者可能会重新消费一次。虽然orderly模式是前一个消费者先解锁，后一个消费者加锁再消费的模式，比起concurrently要严格了，但是加锁的线程和提交offset的线程不是同一个，所以还是会出现极端情况下的重复消费。
3. 还有在发送批量消息的时候，会被当做一条消息进行处理，那么如果批量消息中有一条业务处理成功，其他失败了，还是会被重新消费一次。
4. 生产者多次投递：生产者给mq发消息，mq收到消息之后需要给生产者一个确认回复，如果此时生产者和mq之间的连接断开了，生产者就收不到这个确认回复，就会多次投递。
5. 那么如果在CLUSTERING（负载均衡）模式下，并且在同一个消费者组中，不希望一条消息被重复消费，改怎么办呢？我们可以想到去重操作，找到消息唯一的标识，可以是msgId也可以是你自定义的唯一的key，这样就可以去重了



## 6.2 解决方案

### 6.2.1 概述

* 使用去重方案解决，例如**将消息的唯一标识存起来，然后每次消费之前先判断是否存在这个唯一标识，如果存在则不消费，如果不存在则消费，并且消费以后将这个标记保存。**消息id是全局唯一标识，但在某些情况下，可能会存在相同的消息有两个不同的msgId的情况（消费者主动重发，因客户端重投机制导致的重复等），这种情况就需要使用业务字段进行去重处理。可以为每条消息设置一个key，在业务层面保证这个key是唯一的，例如使用mysql的主键值。

* 想法很好，但是消息的体量是非常大的，可能在生产环境中会到达上千万甚至上亿条，那么我们该如何选择一个容器来保存所有消息的标识，并且又可以快速的判断是否存在呢？

* 一些可以存放这个标记的容器

  * 内存中的map是不行的，因为机器重启之后，这些标记就没有了。此外，如果消费者在两个机器上，其内存也是不共享的。
  * redis可以
  * mysql可以

* 我们可以选择**布隆过滤器(BloomFilter)**
  		布隆过滤器（Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都比一般的算法要好的多，缺点是有一定的误识别率和删除困难。布隆过滤器判断一个元素有是可能有，无是一定无

  ​		在hutool的工具中我们可以直接使用，当然你自己使用redis的bitmap类型手写一个也是可以的 https://hutool.cn/docs/#/bloomFilter/%E6%A6%82%E8%BF%B0 

* 去重是在消费者方进行处理的。消费者需要控制消息的幂等性。所谓幂等性就是指：多次操作产生的影响均和第一次操作产生的影响相同。



### 6.2.2 通过mysql实现去重

* 思路：在mysql数据库中创建一张表（通常成为去重表），并为其设置一个唯一性字段，当接收到消息时，就向该去重表中插入一条记录，如果插入成功，说明该消息未消费，如果插入失败，说明该消息已经消费过了。

* 数据库表`order_oper_log`：

  ![image-20250512225057500](F:\JavaCode\MessageQueue\RocketMQ\document\image\image-20250512225057500.png)

  其中订单编号设置成了唯一索引

* 依赖

  ```xml
  <dependency>
      <groupId>mysql</groupId>
      <artifactId>mysql-connector-java</artifactId>
  </dependency>
  <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-jdbc</artifactId>
  </dependency>
  ```

* 配置文件

  ```
  spring:
    datasource:
      driver-class-name: com.mysql.cj.jdbc.Driver
      username: root
      password: ***
      url: jdbc:mysql://localhost:3306/zw?serverTimezone=UTC&useSSL=false&useUnicode=true&characterEncoding=utf-8
  ```

* 发送消息

  ```java
  @Test
  public void repeatProducer() throws Exception{
      DefaultMQProducer producer = new DefaultMQProducer("repeat-producer-group");
      producer.setNamesrvAddr("111.119.211.126:9876");
      producer.start();
      String key = UUID.randomUUID().toString(); // 模拟订单编号
      System.out.println(key);
      // 模拟发送两条一模一样的消息
      Message message1 = new Message("repeatTopic", null, key, "扣减库存-1".getBytes());
      Message message2 = new Message("repeatTopic", null, key, "扣减库存-1".getBytes());
      producer.send(message1);
      producer.send(message2);
      producer.shutdown();
  }
  ```

  模拟同一个订单的相同处理消息重复发送了两次

* 接收消息

  ```java
  @Test
  public void repeatConsumer() throws Exception {
      DefaultMQPushConsumer consumer = new DefaultMQPushConsumer("repeat-consumer-group");
      consumer.setNamesrvAddr("111.119.211.126:9876");
      consumer.subscribe("repeatTopic", "*");
      consumer.registerMessageListener((MessageListenerConcurrently) (list, context) -> {
          // 先获取消息的key
          String keys = list.get(0).getKeys();
          String sql = "insert into order_oper_log(`type`, `order_sn`, `userId`) values (1, ?, 6)";
          try {
              jdbcTemplate.update(sql, keys);
          } catch (DuplicateKeyException e) {
              // 捕捉到DuplicateKeyException异常，说明执行sql失败了
              System.out.println("消息已成功消费");
              return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
          }
  
          // 处理业务逻辑 
          // 注意如果这里执行业务逻辑要try catch
          // 如果业务报错，需要将插入数据库的数据删除
          // 因为业务报错，RocketMQ隔一段时间会重新发送该消息，
          // 此时数据库中如果有数据，就不能在进行业务逻辑处理了。
          System.out.println("接收到消息：" + new String(list.get(0).getBody()) + "，keys：" + keys);
          return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
      });
      consumer.start();
      System.in.read();
  }
  ```
  
  以上测试是在SpringBoot的test环境下进行的，引入jdbc依赖后，会自动将配置文件的数据源信息读取，创建出一个JDBCTemplate对象，我们只需要在测试类中注入该对象即可。







# 七. 重试机制与死信

## 7.1 生产者重试

```java
@Test
public void retryProducer() throws Exception{
    DefaultMQProducer producer = new DefaultMQProducer("retry-producer-group");
    producer.setNamesrvAddr("111.119.211.126:9876");
    producer.start();
    //设置重试次数
    producer.setRetryTimesWhenSendFailed(2); // 同步发送失败时重复2次
    producer.setRetryTimesWhenSendAsyncFailed(2); // 异步发送失败时重复2次
    String key = UUID.randomUUID().toString();
    System.out.println(key);
    Message message = new Message("retryTopic", "vip", key, "扣减库存-1".getBytes());
    producer.send(message);
    producer.shutdown();
}
```



## 7.2 消费者重试

```java
@Test
public void retryConsumer() throws Exception{
    // 1. 创建消费者
    DefaultMQPushConsumer consumer = new DefaultMQPushConsumer("retry-consumer-group");
    // 2. 连接NameServer
    consumer.setNamesrvAddr("111.119.211.126:9876");
    // 3. 订阅主题和标签
    consumer.subscribe("retryTopic", "vip"); //只订阅vip
    // 设置最大重试次数
    consumer.setMaxReconsumeTimes(2);
    // 4. 注册监听器
    consumer.registerMessageListener((MessageListenerConcurrently) (list, contest) -> {
        System.out.println(new Date());
        System.out.println("我是vip，我正在消费消息：" + new String(list.get(0).getBody()));
        System.out.println("重试次数：" + list.get(0).getReconsumeTimes());// 打印重试次数
        // 业务报错了，返回null，返回RECONSUME_LATER都会重试
        return ConsumeConcurrentlyStatus.RECONSUME_LATER; // 重试
    });
    // 5. 启动消费者
    consumer.start();
    System.in.read();
}
```

* 并发模式下，消费者重试默认次数为16次，每次的时间间隔与延迟消息的间隔匹配，从第3级别开始，即10s，30s，1m，...，1h，2h。顺序模式下，会无限次重复。

* 可以自定义重复次数。在注册监听器之前进行。

  ```java
  consumer.setMaxReconsumeTimes(2);
  ```

* 如果重复了最大次数之后还是失败的，就会成为死信消息，会放在一个死信主题中去。一般死信主题名称为：`%DLQ% + 消费者组名称`。

* 注意：**第一次消费不是重试**，如果最大重复次数是2，那么最多会发送3次该消息。



## 7.3 死信消息

### 7.3.1 介绍

​		当消费重试到达阈值以后，消息不会被投递给消费者了，而是进入了死信队列

​		当一条消息初次消费失败，RocketMQ会自动进行消息重试，达到最大重试次数后，若消费依然失败，则表明消费者在正常情况下无法正确地消费该消息。此时，该消息不会立刻被丢弃，而是将其发送到该消费者对应的特殊队列中，这类消息称为死信消息（Dead-Letter Message），存储死信消息的特殊队列称为死信队列（Dead-Letter Queue），死信队列是死信Topic下分区数唯一的单独队列（死信Topic下只有一个消息队列）。**如果产生了死信消息，那对应的ConsumerGroup的死信Topic名称为`%DLQ%+ 消费者组名称`，死信队列的消息将不会再被消费。可以利用RocketMQ Admin工具或者RocketMQ Dashboard上查询到对应死信消息的信息。我们也可以去监听死信队列，然后进行自己的业务上的逻辑**



### 7.3.2 监听死信队列

以下代码我们实现的是监听7.2中生成的死信队列，即`%DLQretry-consumer-group%`主题。

```java
@Test
public void retryDeadConsumer() throws Exception{
    // 1. 创建消费者
    DefaultMQPushConsumer consumer = new DefaultMQPushConsumer("retry-dead-consumer-group");
    // 2. 连接NameServer
    consumer.setNamesrvAddr("111.119.211.126:9876");
    // 3. 订阅主题和标签
    consumer.subscribe("%DLQ%retry-consumer-group", "*"); //
    // 4. 注册监听器
    consumer.registerMessageListener((MessageListenerConcurrently) (list, contest) -> {
        System.out.println(new Date());
        System.out.println("我是死信队列，我正在消费消息：" + new String(list.get(0).getBody()));
        // 这里可以将此消息记录下来，进行人工处理
        return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
    });
    // 5. 启动消费者
    consumer.start();
    System.in.read();
}
```

以上的这种方法，如果有许多业务，就对应许多主题与消费者组，那么就可能会有许多的死信主题，我们就需要写许多以上的“死信消费者”来处理死信。因此实际中一般采用以下7.3.3中的方式。



### 7.3.3 改造消费者监听死信

```java
@Test
public void retryConsumer() throws Exception {
    // 1. 创建消费者
    DefaultMQPushConsumer consumer = new DefaultMQPushConsumer("retry-consumer-group");
    // 2. 连接NameServer
    consumer.setNamesrvAddr("111.119.211.126:9876");
    // 3. 订阅主题和标签
    consumer.subscribe("retryTopic", "vip"); //只订阅vip

    consumer.setMaxReconsumeTimes(2);
    // 4. 注册监听器
    consumer.registerMessageListener((MessageListenerConcurrently) (list, contest) -> {
        System.out.println(new Date());
        String msg = new String(list.get(0).getBody());
        System.out.println("我是vip，我正在消费消息：" + msg);
        // 处理业务
        try {
            handleDB();
        } catch (Exception e) {
            // 事务回滚等操作
            // 我们定义了最大重试次数是2
            // 第二次重试还失败的话，则进入死信队列，
            if (list.get(0).getReconsumeTimes() >= 2) {
                // 我们在这里签收记录消息，通知人工处理
                System.out.println("消息" + msg + "已签收，等待人工处理");
                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
            }
            // 否则就需要重试
            return ConsumeConcurrentlyStatus.RECONSUME_LATER;
        }
        // 能走到这里说明业务没有报错，正常签收消息。
        return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
    });
    // 5. 启动消费者
    consumer.start();
    System.in.read();
}

private void handleDB() {
    // 假设此方法就是xxxService类中的业务处理方法
    // 模拟一个错误
    int i = 1 / 0;
}
```







# 八. SpringBoot集成rocketMQ

## 8.1 搭建消息生产者

1. pom文件

   ```xml
   <dependency>
       <groupId>org.springframework.boot</groupId>
       <artifactId>spring-boot-starter-web</artifactId>
   </dependency>
   
   <dependency>
       <groupId>org.apache.rocketmq</groupId>
       <artifactId>rocketmq-spring-boot-starter</artifactId>
       <version>2.2.2</version>
   </dependency>
   
   <dependency>
       <groupId>com.alibaba</groupId>
       <artifactId>fastjson</artifactId>
       <version>2.0.44</version>
   </dependency>
   
   <dependency>
       <groupId>org.projectlombok</groupId>
       <artifactId>lombok</artifactId>
       <optional>true</optional>
   </dependency>
   ```

   主要要看看引入的`rocketmq-spring-boot-starter`依赖所关联的`rocketmq-client`的版本号是否与自己安装的rocketMQ的版本号相近。

2. 配置文件application.yml

   ```yml
   rocketmq:
     name-server: 111.119.211.126:9876
     producer:
         group: boot-producer-group
   ```

3. 生产者编写(在test下实现)

   ```java
   @SpringBootTest
   class ProducerApplicationTests {
       @Autowired
       private RocketMQTemplate rocketMQTemplate;
   
       @Test
       public void producerTest() {
           // 发送同步消息
           rocketMQTemplate.syncSend("bootTestTopic", "我是一个同步消息");
   
           // 发送异步消息
           rocketMQTemplate.asyncSend("bootTestTopic", "我是一个异步消息", new SendCallback() {
               @Override
               public void onSuccess(SendResult sendResult) {
                   System.out.println("接收异步消息成功");
               }
   
               @Override
               public void onException(Throwable throwable) {
                   System.out.println("接收异步消息失败");
               }
           });
   
           // 发送单向消息
           rocketMQTemplate.sendOneWay("bootTestTopic", "我发送的是单向消息");
   
           // 发送延时消息
           Message<String> message = MessageBuilder.withPayload("我是一个延时消息").build();
           rocketMQTemplate.syncSend("bootTestTopic", message, 10000, 3);
   
           // 发送顺序消息
           // 创建订单信息
           List<Order> orders = Arrays.asList(
                   new Order("111", 1, "下单"),
                   new Order("111", 1, "物流"),
                   new Order("111", 1, "签收"),
                   new Order("222", 2, "下单"),
                   new Order("222", 2, "物流"),
                   new Order("222", 2, "拒收")
           );
           orders.forEach(order -> {
               // 一般我们发送对象的时候都是使用json
               rocketMQTemplate.syncSendOrderly("bootOrderTopic", JSON.toJSONString(order), order.getOrderSn());
           });
           
           
           // 发送一个带tag的消息
           rocketMQTemplate.syncSend("bootTagTopic:tagA", "我是一个带tag的消息");
           
           // 发送带key的消息
           Message<String> message2 = MessageBuilder.withPayload("我是一个带key的消息").setHeader(RocketMQHeaders.KEYS, "abcde").build;
           rocketMQTemplate.syncSend("bootKeyTopic", message2);
       }
   }
   ```
   
   * 以下的三种发送消息的方法，底层都是调用`syncSend`，发送同步消息
   
     ```
     rocketMQTemplate.syncSend()
     rocketMQTemplate.send()
     rocketMQTemplate.convertAndSend()
     ```
   
   * 发送延时消息时必须要创建一个`Message`类型的对象，并使用如下方法来设置延迟等级
   
     ```java
     syncSend(String destination, Message<?> message, long timeout, int delayLevel);
     // destination: 消息的主题
     // message: 消息
     // timeout: 连接rocketmq的超时时间
     // delayLevel：延迟等级
     ```
   
   * 发送顺序消息，需要将一组消息都发送在同一个队列中，消费者需要单线程消费。
   
   * 发送带标签的消息：就是在各种send方法的destination参数中使用冒号分割即可，在源码`org.apache.rocketmq.spring.support.RocketMQUtil`的`getAndWrapMessage`方法中使用`:`进行分割，获取到`tag`标签
   
     ![img](F:\JavaCode\MessageQueue\RocketMQ\document\image\wps1-1747124820548-1.jpg)
   
   * 发送带`key`的消息，需要创建message对象，将key设置在message的header中。
   
     ```
     使用setHeader(RocketMQHeaders, key)方法来指定key
     
     在消费者处使用messageExt.getKeys()就可以拿到消息的key了
     ```
     
     ​	



## 8.2 搭建消费者

1. pom.xml

   ```xml
   <dependency>
       <groupId>org.springframework.boot</groupId>
       <artifactId>spring-boot-starter-web</artifactId>
   </dependency>
   
   <dependency>
       <groupId>com.alibaba</groupId>
       <artifactId>fastjson</artifactId>
       <version>2.0.44</version>
   </dependency>
   
   <dependency>
       <groupId>org.apache.rocketmq</groupId>
       <artifactId>rocketmq-spring-boot-starter</artifactId>
       <version>2.2.2</version>
   </dependency>
   
   <dependency>
       <groupId>org.projectlombok</groupId>
       <artifactId>lombok</artifactId>
       <optional>true</optional>
   </dependency>
   ```

2. 配置文件

   ```yml
   server:
     port: 8081
   
   rocketmq:
     name-server: 111.119.211.126:9876
     # 一般来说在开发中一个boot项目只对应一个消费者
     # 实际上一个boot项目汇总可以写很多个消费者
   ```

3. 创建一个监听器类

   ```java
   @Data
   @NoArgsConstructor
   @AllArgsConstructor
   public class Order {
       private String orderSn; //订单编号
       private Integer userId; // 用户id
       private String desc; // 描述信息
   }
   ```

   ```java
   @Component
   @RocketMQMessageListener(topic = "bootTestTopic", consumerGroup = "boot-consumer-group")
   public class SimpleMsgListener implements RocketMQListener<MessageExt> {
   
       /**
        * 这个方法就是消费者的方法
        *
        * @param message
        */
       @Override
       public void onMessage(MessageExt message) {
           System.out.println("消费者收到消息：" + new String(message.getBody()));
       }
   }
   ```

   * 如果我们在实现接口`RocketMQListener`时指定了泛型，例如`User`，`String`等，那么`onMessage`方法的参数就是消息体内容
   * 如果我们在实现接口`RocketMQListener`时指定的泛型是`MessageExt`，那么`onMessage`方法的参数就是消息的全部内容，包含`topic,tag`等。
   * 只要`onMessage`方法没报错，消息就签收成功了，报错了，就会拒收，拒收了就会重试

4. 创建一个顺序消息监听器类

   ```java
   @Component
   @RocketMQMessageListener(
           topic = "bootOrderTopic", 
           consumerGroup = "boot-orderly-consumer-group",  
           consumeMode = ConsumeMode.ORDERLY, // 顺序消费模式
           maxReconsumeTimes = 3 // 最大重试次数
   )
   public class OrderlyMsgListener implements RocketMQListener<MessageExt> {
       @Override
       public void onMessage(MessageExt messageExt) {
           Order order = JSON.parseObject(new String(messageExt.getBody()), Order.class);
           System.out.println("接收到消息：" + order);
       }
   }
   ```

   * 顺序消费只需在`@RocketMQMessageListener`注解中将`consumeMode`改为`ConsumeMode.ORDERLY`即可，
   * `consumeMode`默认是`ConsumeMode.CONCURRENTLY`，并发模式

5. 创建一个接收带标签的消息的监听器类

   ```java
   @Component
   @RocketMQMessageListener(
           topic = "bootTagTopic",
           consumerGroup = "boot-tag-consumer-group",
           selectorExpression = "tagA || tagB", // 默认是*
           selectorType = SelectorType.TAG // 默认就是TAG过滤模式
   )
   public class TagMsgListener implements RocketMQListener<MessageExt> {
   
       @Override
       public void onMessage(MessageExt messageExt) {
           System.out.println(new String(messageExt.getBody()));
       }
   }
   ```

   * `selectorType`指定过滤模式，默认就是`TAG`模式。另外一种模式是`SQL92`，这种模式几乎不用，要想使用必须在broker.conf中开启`enablePropertyFilter=true`

     ```
     //如果采用sql92过滤模式
     //标签a就是一个占位符
     rocketMQTemplate.syncSend("bootTagTopic:a", "我是一个带tag的消息");
     
     // 监听器：
     selectorType = SelectorType.SQL92,
     selectorExpression = "a > 5" // a > 5就能被监听
     selectorExpression = "a in (1,3,7)" // a属于1，3,7
     ```





# 九. 两种消息消费模式

​		指消息在**消费者组（Consumer Group）内**的分配和消费方式，即 **消息如何被消费者实例消费**。这是 RocketMQ 的核心消费模式，包含两种类型：集群模式（负载均衡）和广播模式。

## 9.1 集群模式

1. 简介：

   * 集群模式：Clustering。也称为负载均衡模式。

2. 核心机制：

   * 消息分配方式：**同一消费者组内的多个消费者实例分摊消费消息。每条消息只会被组内的一个消费者实例消费。**

   * 队列负载均衡：Topic 的队列（MessageQueue）会通过负载均衡策略（如平均分配、一致性哈希等）分配给组内的消费者实例。例如，一个 Topic 有 8 个队列，消费者组内有 2 个实例，则每个实例可能负责 4 个队列。如果有4个队列，3个消费者，那么可能有两个消费者复杂一个队列，一个消费者负责两个队列。

     ![image-20250511225915200](F:\JavaCode\MessageQueue\RocketMQ\document\image\image-20250511225915200.png)

   * 故障转移：若某个消费者实例宕机，RocketMQ 会自动触发队列重新分配（Rebalance），将该实例负责的队列转移给其他存活实例，避免消息堆积，保证消息不丢失。

   * 新增或减少消费者实例时，RocketMQ 会自动触发 **Rebalance（重平衡）**，重新分配队列，确保负载均衡。

3. 特点：

   * 消息独占性：一条消息仅被消费一次，避免重复处理。
   * 横向扩展能力：通过增加消费者实例数量提升消费能力，天然支持负载均衡。
   * 适用场景：需保证消息顺序性、去重的业务场景，如订单处理、支付回调等。

4. 注意事项：

   * 频繁增减消费者实例会触发 Rebalance，可能导致消费短暂停顿。生产环境中建议保持消费者组稳定。
   * 若队列数远小于消费者实例数，会导致部分实例闲置（无队列可消费）。**建议队列数 >= 消费者实例数**。
   * 集群模式**无法100%避免重复消费**。
   * 合理设置队列数、消费者实例数及分配策略，以最大化吞吐量和稳定性。

5. 配置方式：

   * 普通程序配置方式：

     ```java
     DefaultMQPushConsumer consumer = new DefaultMQPushConsumer("CONSUMER_GROUP_NAME");
     consumer.setMessageModel(MessageModel.CLUSTERING); // 默认即为集群模式
     ```

   * SpringBoot程序配置方式：

     ```java
     @Component
     @RocketMQMessageListener(topic = "TOPIC_NAME",
             consumerGroup = "CONSUMER_GROUP_NAME",
             messageModel = MessageModel.CLUSTERING // 开启负载均衡模式
     )
     public class ConsumerListener implements RocketMQListener<String> {
         @Override
         public void onMessage(String message) {
             System.out.println(message);
         }
     }
     ```



## 9.2 广播模式

1. 简介：

   * 广播模式：Broadcasting。

2. 核心机制

   * **消息分发方式**：同一消费者组内的所有消费者实例**均会收到全量消息**。每条消息会被组内的**所有消费者实例**独立消费。
   * **无队列分配**：消费者组内的每个实例都会订阅 Topic 的所有队列，独立拉取消息，彼此无负载均衡关系。

3. 特点

   * **消息广播**：所有消费者实例独立处理全量消息，适用于需要多副本同步处理的场景。
   * **无故障转移**：若某个实例宕机，不影响其他实例消费，但宕机实例已拉取未处理的消息可能丢失（需业务层保证可靠性）。
   * **适用场景**：需要所有节点同步状态或执行相同操作的场景，如全局配置更新、缓存刷新、日志广播等。

4. 注意事项：

   * **消息堆积**：广播模式下，若某个消费者实例处理能力不足，可能导致该实例消息堆积，需监控消费进度（Consumer Offset）。
   * **顺序性限制**：广播模式无法保证全局消息顺序，仅能在单个实例内保证队列顺序。
   * **消费者位点**：广播模式下，由于每个消费者的消费者位点(消费进度)需要由各个实例自行维护，而非Broker集中管理，不同实例之间的消费进度互不干扰。无论消息接收成功还是失败，mq都不会进行重试。

5. 配置方式：

   * 普通应用程序配置方式：

     ```java
     DefaultMQPushConsumer consumer = new DefaultMQPushConsumer("CONSUMER_GROUP_NAME");
     consumer.setMessageModel(MessageModel.BROADCASTING); 
     ```

   * SpringBoot程序配置方式

     ```
     @Component
     @RocketMQMessageListener(topic = "TOPIC_NAME",
             consumerGroup = "CONSUMER_GROUP_NAME",
             messageModel = MessageModel.BROADCASTING // 开启负载均衡模式
     )
     public class ConsumerListener implements RocketMQListener<String> {
         @Override
         public void onMessage(String message) {
             System.out.println(message);
         }
     }
     ```



## 9.3 两种模式对比与选择

1. 对比：

   | 维度       | 集群模式(Clustering)                     | 广播模式(Broadcasting)                     |
   | ---------- | ---------------------------------------- | ------------------------------------------ |
   | 消息分配   | 消费者组内实例分摊消息(队列级别负载均衡) | 所有实例消费全量消息                       |
   | 重复消费   | 单次消费(天然去重)                       | 所有实例独立消费                           |
   | 横向扩展性 | 可通过增加实例提升消费能力               | 扩展实例会增加整体消费压力                 |
   | 故障恢复   | 自动重平衡，消息由其他实例接管           | 宕机实例的消息可能丢失，需业务补偿         |
   | 顺序性支持 | **队列内**消息严格有序（需单线程消费）   | 无序（所有实例独立拉取）                   |
   | 消费者位点 | mq服务器会记录处理                       | mq服务器不会记录，并且也不会对消息重新投递 |
   | 典型场景   | 订单处理、支付回调、异步任务             | 配置同步、缓存刷新、日志收集               |

2. 选择：

   * **优先集群模式**：在大多数业务场景（如削峰填谷、异步解耦）下，集群模式能更好地平衡性能和可靠性。
   * **谨慎使用广播模式**：仅在需要全量消息同步时使用，需自行处理消息幂等性、实例故障恢复等问题。
   * **混合模式**：同一 RocketMQ 集群中，可为不同 Consumer Group 配置不同模式，灵活适配业务需求。

3. 注意事项：

   ​		消息消费模式是消息在消费者组内的分配方式，**在消费者组之间是完全独立的**。即使它们订阅同一个 Topic，各自的消费模式（集群模式或广播模式）也会独立生效，互不影响。

   ![image-20250513221822147](F:\JavaCode\MessageQueue\RocketMQ\document\image\image-20250513221822147.png)

   如上图所示，生产者P向`testTopic`主题发送了四条消息，消费者组A和消费者组B均订阅了`testTopic`主题。消费者组A采用集群模式，消费者组B采用广播模式。`testTopic`主题中的消息都会以多副本的形式投递到消费者组A和消费者组B中，即**广播到不同组**。由于消费者组A采用了集群模式，组内会采用集群模式对消息进行分配，那么可能消费者A1收到两条消息，消费者A2就会收到另外两条消息。而消费者组B采用了广播模式，那么消费者B1和B2都会收到`testTopic`主题中的全部四条消息。

   ​		消息流转示意图：

   ```
   Producer
       |
       | 发送消息
       V
   Broker (testTopic, 4 Queues)
       |
       | 消息多副本投递
       |-----------------------------
       |                            |
       V                            V
   消费者组 A (集群模式)             消费者组 B (广播模式)
       |                            |
       | 负载均衡：每个实例消费部分队列     | 每个实例消费全部队列
       V                            V
   Instance A1 → Queue 0-1          Instance B1 → Queue 0-3
   Instance A2 → Queue 2-3          Instance B2 → Queue 0-3
   ```

   



# 十. 消息堆积与丢失问题

## 10.1 消息堆积

### 10.1.1 消息堆积的本质与危害

1. 核心定义：
   * **消息堆积**：Broker存储的消息总量超过消费者处理能力，队列深度（Queue Depth）持续增长。
   * **关键指标**：积压消息量（Pending Messages）、消费延迟（Consume Latency）。
2. 直接危害：
   * **系统资源耗尽**：Broker磁盘占满，导致新消息无法写入。
   * **业务延迟激增**：消费者处理陈旧消息，实时性丧失。
   * **级联故障风险**：积压可能触发消费者崩溃，形成恶性循环。



### 10.1.2 消息堆积的原因

1. **生产流量洪峰**
   * 场景：秒杀活动、日志突增、系统故障恢复期。
   * 特征：瞬时TPS远超消费者吞吐上限
2. **消费能力不足**
   * 资源瓶颈：消费者CPU/内存/线程数不足。
   * 逻辑低效：单条消息处理耗时过长（如复杂计算、同步阻塞IO）。
3. **消费端故障**
   * 代码缺陷：消息处理逻辑抛出异常，触发无限重试。
   * 依赖服务宕机：数据库、外部API不可用，导致消费卡死。
4. **网络与配置问题**
   * Broker-消费者网络抖动：消息拉取中断。
   * 消费位点配置错误：消费者从历史位点重启，重复消费旧数据。
5. **队列分配不均**
   * 负载均衡失效：部分队列消息量远高于其他队列，消费者实例负载倾斜。
6. **死信堆积**
   * 重试策略不当：消息反复进入重试队列，最终堆积在死信Topic。



### 10.1.3 解决方案

| 策略                 | 操作步骤                                                     | 适用场景                   |
| -------------------- | ------------------------------------------------------------ | -------------------------- |
| **消费者水平扩容**   | 1.动态增加消费者数量<br />2.Topic队列数≥实例数（避免闲置）   | 消费能力不足导致的线性积压 |
| **临时提升消费并发** | 1.调整消费者线程数（`consumeThreadMin/Max`）<br />2.启用异步消费模式 | CPU/IO密集型任务           |
| 跳过非关键消息       | 1. 修改消费者位点（`resetOffset`）至最新位置(跳过堆积)<br />2.后续通过补偿任务处理积压 | 历史数据可延迟处理         |
| 降级非核心业务       | 1.关闭次要消费者的订阅 <br />2.集中资源处理核心消息          | 多业务共享集群时的资源争用 |
| 生产方业务限流       |                                                              |                            |

* 设置最大的消费线程数量时要根据任务类型来设置。假设服务器的最大线程数为n，如果是CPU密集型任务，那么最大线程数设置为`(n+1)`，避免频繁切换线程；如果是IO密集型任务，那么最大线程数设置为`2n`
* **可以增加队列数量从而增加消费者数量**。但一般队列数量的增加或减少由运维来决定，一开始设置好之后，最好就不要更改了，一般就是四个或者八个。在RocketMQ控制台中点击主题，点击对应主题的TOPIC配置之后即可修改队列数量。
* 跳过堆积是不可逆的，需要慎重，在RocketMQ的控制台上就可以



## 10.2 消息丢失

### 10.2.1 生产端消息丢失

* 出现原因：生产者发送消息到Broker时，网络突然中断或者是生产者采用异步发送方式，消息暂存内存队列后进程意外退出。
* 解决办法：
  * 采用同步发送，确保消息发送成功后再返回结果。
  * 事务消息，适用于强一致性场景。
  * **消息缓存**：在生产中，一般会采用异步的方式发送消息（为了效率）。我们可以在发送消息完成之后，在mysql中记录该消息的key，createTime和status，并将status设置为1表示消息未消费。当消费者接收消息并处理之后，就将mysql中该记录对应的status设置为0。如果mysql中某条记录的status好几天一直是1，说明该消息可能丢失了。可以开启一个定时任务，每天查询一次，看看哪些消息创建已经超过一天了，但状态值status仍然是1，查询出来对应的消息进行补发。需要注意补发消息就要做好幂等性，避免消息的重复消费。



### 10.2.2 Broker端消息丢失

* 出现原因：
  * **刷盘策略不可靠**：刷盘策略采用异步刷盘，消息写入内存中的缓冲区之后宕机了，未同步到磁盘中。
  * **主从同步失败**：Broker采用异步主从复制（`ASYNC_MASTER`），主节点写入后未同步到Slave即宕机。Slave未持有消息副本，主节点数据无法恢复。
  * **磁盘故障：**Broker磁盘损坏或存储介质（如SSD）发生物理故障。持久化到磁盘的消息因硬件问题丢失。
  * **运维误操作**：误执行`deleteTopic`命令或手动删除CommitLog文件。消息数据被人工删除且无备份。
* 解决办法：
  * 采用同步刷盘策略：消息写入磁盘后才返回ACK，可靠性最高。
  * 采用同步复制策略：消息写入Slave后才返回ACK，彻底避免单点故障。
  * 采用多磁盘备份。将消息持久化到不同的硬件上。



### 10.2.3 消息跟踪机制

1. 在broker.conf中开启消息追踪

   ```
   traceTopicEnable=true
   ```

2. 重启broker即可

3. 生产者开启消息轨迹

   * SpringBoot程序

     ```
     enable-msg-trace: true
     ```

   * 原生api

     ```java
     new DefaultMQProducer(“test-producer-group”, true);
     ```

4. 消费者开启消息轨迹功能，可以给单独的某一个消费者开启

   ```
   在消费者的@RocketMQMessageListener注解中开启
   enableMsgTrace = true
   ```

5. 在rocketmq的面板中可以查看消息轨迹。默认会将消息轨迹的数据存在`RMQ_SYS_TRACE_TOPIC` 主题里面





# 十一. 安全性

1. 开启acl控制：在broker.conf文件中配置

   ```
   aclEnable=true
   ```

2. 配置账号密码：修改plain_acl.yml

3. 在应用程序的配置文件中设置账号和密码即可。

4. 开启acl之后，控制台连接NameServer监控Broker也需要acl的账号密码，需要修改控制面板所对应的jar包的配置文件application.properties。

   ![image-20250514112417840](F:\JavaCode\MessageQueue\RocketMQ\document\image\image-20250514112417840.png)

5. 如果我们想要在访问控制面板时也需要登录的话，需要修改application.properties配置文件的以下配置

   ![image-20250514112611847](F:\JavaCode\MessageQueue\RocketMQ\document\image\image-20250514112611847.png)

   需要注意，登录这个控制面板的账号密码在控制台这个jar包所对应的SpringBoot程序的users.properties属性配置文件中定义的。

6. 将application.properties上传到服务器的jar包平级目录下即可，运行jar包时优先使用这个上传的配置文件。







# 十二. 秒杀

## 12.1 技术选型

* Springboot：接收请求并操作redis和mysql
* redis： 用于缓存+分布式锁
* RocketMQ： 用于解耦 削峰，异步
* Mysql：用于存放真实的商品信息
* Mybatis：用与操作数据库的orm框架



## 12.2 架构图

![image-20250514173906870](F:\JavaCode\MessageQueue\RocketMQ\document\image\image-20250514173906870.png)



## 12.3 数据库设计

1. 商品表

   ```mysql
   SET NAMES utf8mb4;
   SET FOREIGN_KEY_CHECKS = 0;
   
   -- ----------------------------
   -- Table structure for goods
   -- ----------------------------
   DROP TABLE IF EXISTS `goods`;
   CREATE TABLE `goods`  (
     `id` int(11) NOT NULL AUTO_INCREMENT,
     `goods_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL,
     `price` decimal(10, 2) NULL DEFAULT NULL,
     `stocks` int(255) NULL DEFAULT NULL,
     `status` int(255) NULL DEFAULT NULL,
     `pic` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL,
     `create_time` datetime(0) NULL DEFAULT NULL,
     `update_time` datetime(0) NULL DEFAULT NULL,
     `spike` int(11) DEFAULT 1 COMMENT '是否参与秒杀 1是0否',
     PRIMARY KEY (`id`) USING BTREE
   ) ENGINE = InnoDB AUTO_INCREMENT = 4 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = Dynamic;
   
   INSERT INTO `goods` VALUES (1, '小米12s', 4999.00, 1000, 2, 'xxxxxx', '2023-02-23 11:35:56', '2023-02-23 16:53:34');
   INSERT INTO `goods` VALUES (2, '华为mate50', 6999.00, 10, 2, 'xxxx', '2023-02-23 11:35:56', '2023-02-23 11:35:56');
   INSERT INTO `goods` VALUES (3, '锤子pro2', 1999.00, 100, 1, NULL, '2023-02-23 11:35:56', '2023-02-23 11:35:56');
   ```

2. 订单记录表

   ```mysql
   DROP TABLE IF EXISTS `order_records`;
   CREATE TABLE `order_records`  (
     `id` int(11) NOT NULL AUTO_INCREMENT,
     `user_id` int(11) NULL DEFAULT NULL,
     `order_sn` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL,
     `goods_id` int(11) NULL DEFAULT NULL,
     `create_time` datetime(0) NULL DEFAULT NULL,
     PRIMARY KEY (`id`) USING BTREE
   ) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = Dynamic;
   
   SET FOREIGN_KEY_CHECKS = 1;
   ```

   

## 12.4 创建模块seckill-web

​		该模块用于接收用户秒杀请求。

### 12.4.1 依赖

```
1. web启动器 spring-boot-starter-web
2. lombok依赖 lombok
3. rocketmq启动器  rocketmq-spring-boot-starter
4. redis启动器 spring-boot-starter-data-redis
5. fastjson依赖 fastjson
```

### 12.4.2 配置文件

```yml
server:
  port: 8081
  tomcat:
    threads:
      max: 400

spring:
  redis:
    port: 6379
    host: 111.119.211.126
    password: ****
    database: 0

rocketmq:
  name-server: 111.119.211.126:9876
```

### 12.4.3 Controller

```java
@RestController
public class SeckillController {

    @Autowired
    private StringRedisTemplate redisTemplate;
    @Autowired
    private RocketMQTemplate rocketMQTemplate;

    /**
     * 秒杀
     *
     * @param goodsId 商品id
     * @param userId  用户id，真实项目用户需要登录，用户id不用传递，是从SpringSecurity中获取
     * @return
     */
    @GetMapping("seckill")
    public String doSeckill(Integer goodsId, Integer userId) {
        // 1. 用户去重 uk uniqueKey = goodsId + userId
        String uk = goodsId + "-" + userId;
        Boolean flag = redisTemplate.opsForValue().setIfAbsent(uk, "");//setnx
        if (!flag) {
            return "重复秒杀, 参与失败O(n_n)O~";
        }

        // 2. 库存的预扣减 redis中存入 goodsId:stock
        // 先查询后修改是线程不安全的，所以直接使用redis的derc key命令
        // redisTemplate中该命令的api接口是decrement,返回值是减一之后的结果
        Long count = redisTemplate.opsForValue().decrement("goodsId:" + goodsId);
        if (count < 0) {
            return "库存不足，秒杀失败O(n_n)O~";
        }

        // 3. 消息放入mq 异步处理
        rocketMQTemplate.asyncSend("seckillTopic", uk, new SendCallback() {
            @Override
            public void onSuccess(SendResult sendResult) {
                System.out.println("发送成功");
            }

            @Override
            public void onException(Throwable e) {
                System.out.println("用户id：" + userId + ", 商品id：" + goodsId + "\t发送失败" + e.getMessage());
            }
        });
        return "正在拼命抢购中,请稍后到订单中心查看";
    }
}
```





## 12.5 创建模块seckill-service

该模块用来处理mysql数据库的数据以及与redis数据库的同步

### 12.5.1 依赖

```
1. web启动器 spring-boot-starter-web
2. lombok依赖 lombok
3. rocketmq启动器  rocketmq-spring-boot-starter
4. redis启动器 spring-boot-starter-data-redis
5. mysql依赖 mysql-connector-j
6. mybatis启动器 mybatis-spring-boot-starter
```

