# 一. MQ简介

## 1.1 为什么要使用MQ

* 要做到系统解耦，当新的模块进来时，可以做到代码改动最小;  **能够解耦**
* 设置流程缓冲池，可以让后端系统按自身吞吐能力进行消费，不被冲垮; **能够削峰，限流**
* 强弱依赖梳理能把非关键调用链路的操作异步化并提升整体系统的吞吐能力;**能够异步**

***Mq的作用  削峰限流 异步 解耦合***



## 1.2 定义

* 中间件是什么？
  * 中间件（缓存中间件  redis memcache  数据库中间件 mycat  canal   消息中间件mq ）
  * 面向消息的中间件(message-oriented middleware) MOM能够很好的解决以上的问题。是指利用高效可靠的消息传递机制进行与平台无关（跨平台）的数据交流，并基于数据通信来进行分布式系统的集成。

* 通过提供**消息传递和消息排队模型**在分布式环境下提供应用解耦，弹性伸缩，冗余存储，流量削峰，异步通信，数据同步等
* 大致流程
  * 发送者把消息发给消息服务器[MQ]，
  * 消息服务器把消息存放在若干**队列/主题**中
  * 在合适的时候，消息服务器会把消息转发给接受者。
* 在这个过程中，发送和接受是异步的,也就是发送无需等待，发送者和接受者的生命周期也没有必然关系在发布pub/订阅sub模式下，也可以完成一对多的通信，可以让一个消息有多个接受者[微信订阅号就是这样的]

![img](F:\JavaCode\MessageQueue\RocketMQ\document\image\wps1.jpg)

## 1.3 特点

### 1.3.1 异步处理模式

​	消息发送者可以发送一个消息而无需等待响应。消息发送者把消息发送到一条虚拟的通道(主题或队列)上;

​	消息接收者则订阅或监听该通道。一条信息可能最终转发给一个或多个消息接收者，这些接收者都无需对消息发送者做出回应。整个过程都是异步的。

​	也就是说，一个系统和另一个系统间进行通信的时候，假如系统A希望发送一个消息给系统B，让它去处理，但是系统A不关注系统B到底怎么处理或者有没有处理好，所以系统A把消息发送给MQ，然后就不管这条消息的“死活” 了，接着系统B从MQ里面消费出来处理即可。至于怎么处理，是否处理完毕，什么时候处理，都是系统B的事，与系统A无关。

![img](F:\JavaCode\MessageQueue\RocketMQ\document\image\wps2.jpg)

这样的一种通信方式，就是所谓的“异步”通信方式，对于系统A来说，只要把消息发给MQ,然后系统B就会异步处去进行处理了，系统A不能“同步”的等待系统B处理完。这样的好处是什么呢？**解耦**

### 1.3.2 应用系统的解耦

  发送者和接收者不必了解对方，只需要确认消息
  发送者和接收者不必同时在线

### 1.3.3 现实中的业务

![image-20250414151713214](F:\JavaCode\MessageQueue\RocketMQ\document\image\image-20250414151713214.png)



## 1.4 各种MQ产品的比较

![image-20250414151819771](F:\JavaCode\MessageQueue\RocketMQ\document\image\image-20250414151819771.png)

![image-20250414153450707](F:\JavaCode\MessageQueue\RocketMQ\document\image\image-20250414153450707.png)







# 二. RocketMQ基础

## 2.1 RocketMQ简介

* 官网：http://rocketmq.apache.org/

* 介绍：

  >RocketMQ是阿里巴巴2016年MQ中间件，使用Java语言开发，RocketMQ 是一款开源的**分布式消息系统**，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务。同时，广泛应用于多个领域，包括异步通信解耦、企业解决方案、金融支付、电信、电子商务、快递物流、广告营销、社交、即时通信、移动应用、手游、视频、物联网、车联网等。

* 具有以下特点：

  * 能够保证严格的消息顺序
  * 提供丰富的消息拉取模式
  * 高效的订阅者水平扩展能力
  * 实时的消息订阅机制
  * 亿级消息堆积能力



## 2.2 RocketMQ相关概念

* **Producer**：消息的发送者，生产者；举例：发件人
* **Consumer**：消息接收者，消费者；举例：收件人
* **Broker**：暂存和传输消息的通道；举例：快递
* **NameServer**：管理Broker；举例：各个快递公司的管理机构 相当于broker的注册中心，保留了broker的信息
* **Queue**：队列，消息存放的位置，**一个Broker中可以有多个队列**。【实际存放的是消息的地址，而不是消息本身】
* **Topic**：主题，消息的分类
* ProducerGroup：生产者组
* ConsumerGroup：消费者组，多个消费者组可以同时消费一个主题的消息



## 2.3 消息发送流程

消息发送的流程是，Producer询问NameServer，NameServer分配一个broker（每一个broker都还有从机），然后Consumer也要询问NameServer，得到一个具体的broker，然后消费消息。以下图是一个单机版的RocketMQ。

![img](F:\JavaCode\MessageQueue\RocketMQ\document\image\wps1-1746870218860-1.jpg)



## 2.4 生产和消费的理解

![img](F:\JavaCode\MessageQueue\RocketMQ\document\image\wps2-1746871954103-3.jpg)

## 2.5 安装

### 2.5.1 下载RocketMQ

* 下载地址：https://rocketmq.apache.org/zh/download

* 注意选择版本，这里我们选择4.9.2的版本，与后面使用alibaba时对应

  ![image-20250510191403080](F:\JavaCode\MessageQueue\RocketMQ\document\image\image-20250510191403080.png)

  下载bin文件



### 2.5.2 下载RocketMQ控制台

* Rocketmq 控制台可以可视化MQ的消息发送！
* 网址：https://rocketmq.apache.org/zh/docs/deploymentOperations/04Dashboard/



### 2.5.3 上传服务器

* 在root目录下新建文件夹

  ```
  mkdir rocketmq
  ```

* 将bin文件的压缩包和控制台的jar包上传上去

  ![image-20250510195533529](F:\JavaCode\MessageQueue\RocketMQ\document\image\image-20250510195533529.png)



### 2.5.4 解压

```
unzip rocketmq-all-4.9.2-bin-release.zip
```

如果你的服务器没有unzip命令，则下载安装一个

```
yum install unzip
```

目录分析：

![image-20250510195610685](F:\JavaCode\MessageQueue\RocketMQ\document\image\image-20250510195610685.png)

* Benchmark：包含一些性能测试的脚本；
* Bin：可执行文件目录；
* Conf：配置文件目录；
* Lib：第三方依赖；
* LICENSE：授权信息;
* NOTICE：版本公告；



### 2.5.5 配置环境变量

```
vim /etc/profile
```

在文件末尾添加

```
export NAMESRV_ADDR=阿里云公网IP:9876
```

刷新环境变量

```
source /etc/profile
```



### 2.5.6 修改nameServer的运行脚本

进入bin目录下，修改runserver.sh文件,将71行和76行的Xms和Xmx以及Xmn等改小一点

```
vim runserver.sh
```

![image-20250510200756427](F:\JavaCode\MessageQueue\RocketMQ\document\image\image-20250510200756427.png)



### 2.5.7 修改broker的运行脚本

进入bin目录下，修改runbroker.sh文件,修改67行

```
vim runbroker.sh
```

![image-20250510201051789](F:\JavaCode\MessageQueue\RocketMQ\document\image\image-20250510201051789.png)



### 2.5.8 修改broker的配置文件

进入conf目录下，修改broker.conf文件

```
brokerClusterName = DefaultCluster
brokerName = broker-a
brokerId = 0
deleteWhen = 04
fileReservedTime = 48
brokerRole = ASYNC_MASTER
flushDiskType = ASYNC_FLUSH
namesrvAddr=localhost:9876
autoCreateTopicEnable=true
brokerIP1=阿里云公网IP
```

* namesrvAddr：nameSrv的地址，可以写localhost，因为nameSrv和broker在一个服务器上。
* autoCreateTopicEnable：自动创建主题，不然需要手动创建出来
* brokerIP1：broker也需要一个公网ip，如果不指定，那么是阿里云的内网地址，我们再本地无法连接使用