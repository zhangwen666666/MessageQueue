# 一. MQ简介

## 1.1 为什么要使用MQ

* 要做到系统解耦，当新的模块进来时，可以做到代码改动最小;  **能够解耦**
* 设置流程缓冲池，可以让后端系统按自身吞吐能力进行消费，不被冲垮; **能够削峰，限流**
* 强弱依赖梳理能把非关键调用链路的操作异步化并提升整体系统的吞吐能力;**能够异步**

***Mq的作用  削峰限流 异步 解耦合***



## 1.2 定义

* 中间件是什么？
  * 中间件（缓存中间件  redis memcache  数据库中间件 mycat  canal   消息中间件mq ）
  * 面向消息的中间件(message-oriented middleware) MOM能够很好的解决以上的问题。是指利用高效可靠的消息传递机制进行与平台无关（跨平台）的数据交流，并基于数据通信来进行分布式系统的集成。

* 通过提供**消息传递和消息排队模型**在分布式环境下提供应用解耦，弹性伸缩，冗余存储，流量削峰，异步通信，数据同步等
* 大致流程
  * 发送者把消息发给消息服务器[MQ]，
  * 消息服务器把消息存放在若干**队列/主题**中
  * 在合适的时候，消息服务器会把消息转发给接受者。
* 在这个过程中，发送和接受是异步的,也就是发送无需等待，发送者和接受者的生命周期也没有必然关系在发布pub/订阅sub模式下，也可以完成一对多的通信，可以让一个消息有多个接受者[微信订阅号就是这样的]

![img](F:\JavaCode\MessageQueue\RocketMQ\document\image\wps1.jpg)

## 1.3 特点

### 1.3.1 异步处理模式

​	消息发送者可以发送一个消息而无需等待响应。消息发送者把消息发送到一条虚拟的通道(主题或队列)上;

​	消息接收者则订阅或监听该通道。一条信息可能最终转发给一个或多个消息接收者，这些接收者都无需对消息发送者做出回应。整个过程都是异步的。

​	也就是说，一个系统和另一个系统间进行通信的时候，假如系统A希望发送一个消息给系统B，让它去处理，但是系统A不关注系统B到底怎么处理或者有没有处理好，所以系统A把消息发送给MQ，然后就不管这条消息的“死活” 了，接着系统B从MQ里面消费出来处理即可。至于怎么处理，是否处理完毕，什么时候处理，都是系统B的事，与系统A无关。

![img](F:\JavaCode\MessageQueue\RocketMQ\document\image\wps2.jpg)

这样的一种通信方式，就是所谓的“异步”通信方式，对于系统A来说，只要把消息发给MQ,然后系统B就会异步处去进行处理了，系统A不能“同步”的等待系统B处理完。这样的好处是什么呢？**解耦**

### 1.3.2 应用系统的解耦

  发送者和接收者不必了解对方，只需要确认消息
  发送者和接收者不必同时在线

### 1.3.3 现实中的业务

![image-20250414151713214](F:\JavaCode\MessageQueue\RocketMQ\document\image\image-20250414151713214.png)



## 1.4 各种MQ产品的比较

![image-20250414151819771](F:\JavaCode\MessageQueue\RocketMQ\document\image\image-20250414151819771.png)

![image-20250414153450707](F:\JavaCode\MessageQueue\RocketMQ\document\image\image-20250414153450707.png)







# 二. RocketMQ基础

## 2.1 RocketMQ简介

* 官网：http://rocketmq.apache.org/

* 介绍：

  >RocketMQ是阿里巴巴2016年MQ中间件，使用Java语言开发，RocketMQ 是一款开源的**分布式消息系统**，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务。同时，广泛应用于多个领域，包括异步通信解耦、企业解决方案、金融支付、电信、电子商务、快递物流、广告营销、社交、即时通信、移动应用、手游、视频、物联网、车联网等。

* 具有以下特点：

  * 能够保证严格的消息顺序
  * 提供丰富的消息拉取模式
  * 高效的订阅者水平扩展能力
  * 实时的消息订阅机制
  * 亿级消息堆积能力



## 2.2 RocketMQ相关概念

* **Producer**：消息的发送者，生产者；举例：发件人
* **Consumer**：消息接收者，消费者；举例：收件人
* **Broker**：暂存和传输消息的通道；举例：快递
* **NameServer**：管理Broker；举例：各个快递公司的管理机构 相当于broker的注册中心，保留了broker的信息
* **Queue**：队列，消息存放的位置，**一个Broker中可以有多个队列**。【实际存放的是消息的地址，而不是消息本身】
* **Topic**：主题，消息的分类
* ProducerGroup：生产者组
* ConsumerGroup：消费者组，多个消费者组可以同时消费一个主题的消息



## 2.3 消息发送流程

消息发送的流程是，Producer询问NameServer，NameServer分配一个broker（每一个broker都还有从机），然后Consumer也要询问NameServer，得到一个具体的broker，然后消费消息。以下图是一个单机版的RocketMQ。

![img](F:\JavaCode\MessageQueue\RocketMQ\document\image\wps1-1746870218860-1.jpg)



## 2.4 生产和消费的理解

![img](F:\JavaCode\MessageQueue\RocketMQ\document\image\wps2-1746871954103-3.jpg)

## 2.5 安装

### 2.5.1 下载RocketMQ

* 下载地址：https://rocketmq.apache.org/zh/download

* 注意选择版本，这里我们选择4.9.2的版本，与后面使用alibaba时对应

  ![image-20250510191403080](F:\JavaCode\MessageQueue\RocketMQ\document\image\image-20250510191403080.png)

  下载bin文件



### 2.5.2 下载RocketMQ控制台

* Rocketmq 控制台可以可视化MQ的消息发送！
* 网址：https://rocketmq.apache.org/zh/docs/deploymentOperations/04Dashboard/



### 2.5.3 上传服务器

* 在root目录下新建文件夹

  ```
  mkdir rocketmq
  ```

* 将bin文件的压缩包和控制台的jar包上传上去

  ![image-20250510195533529](F:\JavaCode\MessageQueue\RocketMQ\document\image\image-20250510195533529.png)



### 2.5.4 解压

```
unzip rocketmq-all-4.9.2-bin-release.zip
```

如果你的服务器没有unzip命令，则下载安装一个

```
yum install unzip
```

目录分析：

![image-20250510195610685](F:\JavaCode\MessageQueue\RocketMQ\document\image\image-20250510195610685.png)

* Benchmark：包含一些性能测试的脚本；
* Bin：可执行文件目录；
* Conf：配置文件目录；
* Lib：第三方依赖；
* LICENSE：授权信息;
* NOTICE：版本公告；



### 2.5.5 配置环境变量

```
vim /etc/profile
```

在文件末尾添加

```
export NAMESRV_ADDR=阿里云公网IP:9876
```

刷新环境变量

```
source /etc/profile
```



### 2.5.6 修改nameServer的运行脚本

进入bin目录下，修改runserver.sh文件,将71行和76行的Xms和Xmx以及Xmn等改小一点

```
vim runserver.sh
```

![image-20250510200756427](F:\JavaCode\MessageQueue\RocketMQ\document\image\image-20250510200756427.png)



### 2.5.7 修改broker的运行脚本

进入bin目录下，修改runbroker.sh文件,修改67行

```
vim runbroker.sh
```

![image-20250510201051789](F:\JavaCode\MessageQueue\RocketMQ\document\image\image-20250510201051789.png)



### 2.5.8 修改broker的配置文件

进入conf目录下，修改broker.conf文件

```
brokerClusterName = DefaultCluster
brokerName = broker-a
brokerId = 0
deleteWhen = 04
fileReservedTime = 48
brokerRole = ASYNC_MASTER
flushDiskType = ASYNC_FLUSH
namesrvAddr=111.119.211.126:9876
autoCreateTopicEnable=true
brokerIP1=阿里云公网IP
```

* namesrvAddr：nameSrv的地址，可以写localhost，因为nameSrv和broker在一个服务器上。
* autoCreateTopicEnable：自动创建主题，不然需要手动创建出来
* brokerIP1：broker也需要一个公网ip，如果不指定，那么是阿里云的内网地址，我们再本地无法连接使用



### 2.5.9 启动nameserver和broker

* 首先在安装目录下创建一个logs文件夹，用于存放日志

  ```
  mkdir logs
  ```

  ![image-20250510210658229](F:\JavaCode\MessageQueue\RocketMQ\document\image\image-20250510210658229.png)

* 在bin目录下执行：

  * 启动nameserver

    ```
    # nohup表示在后台运行，不占用控制台
    # 执行mqnamesrv脚本文件，输出日志到namesrv.log文件中
    nohup sh mqnamesrv > ../logs/namesrv.log &
    ```

  * 启动broker

    ```
    # 这里的-c是指定使用的配置文件
    nohup sh mqbroker -c ../conf/broker.conf > ../logs/broker.log &
    ```

* 可以使用`jps -l`命令查看java应用的进程号

  ![image-20250510211326726](F:\JavaCode\MessageQueue\RocketMQ\document\image\image-20250510211326726.png)

  

### 2.5.10 启动RocketMQ控制台

```
nohup java -jar ./rocketmq-dashboard-1.0.0.jar --server.port=8001 --rocketmq.config.namesrvAddr=127.0.0.1:9876 > ./rocketmq-4.9.2/logs/dashboard.log &
```

* `--server.port=8001` : 指定端口号，默认是8080.
* `--rocketmq.config.namesrvAddr=127.0.0.1:9876`：指定namesrv地址。

![image-20250510212106851](F:\JavaCode\MessageQueue\RocketMQ\document\image\image-20250510212106851.png)

**注意要在安全组策略中放开9876和10100-11000端口。**



## 2.6 Docker部署RocketMQ

### 2.6.1 下载镜像

```
docker pull apache/rocketmq:4.9.2 # rocketmq镜像
docker pull apacherocketmq/rocketmq-dashboard:1.0.0 # 控制台镜像
```

### 2.6.2 创建容器共享网络

RocketMQ中有多个服务，需要创建多个容器，创建 docker 网络便于容器间相互通信。

```
docker network create rocketmq
```

### 2.6.3 启动NameServer

* 创建NameServer数据存储路径

  ```
  mkdir -p /root/rocketmq/data/namesrv/logs /root/rocketmq/data/namesrv/store
  ```

* 启动NameServer容器

  ```
  docker run -d --name rmqnamesrv -p 9876:9876 \
  -v /root/rocketmq/data/namesrv/logs:/root/logs \
  -v /root/rocketmq/data/namesrv/store:/root/store \
  -e "MAX_POSSIBLE_HEAP=100000000" \
  --net rocketmq \
  apache/rocketmq:4.9.2 sh mqnamesrv
  ```

* 查看是否启动成功

  ```
  docker logs -f rmqnamesrv # rmqnamesrv是容器的名字
  ```

### 2.6.4 启动Broker

* 创建Broker数据存储路径

  ```
  mkdir -p /root/rocketmq/data/broker/logs /root/rocketmq/data/broker/store
  ```

* 创建conf配置文件目录

  ```
  mkdir /root/rocketmq/conf
  ```

* 在配置文件目录下新建broker.conf配置文件，内容如下

  ```
  # 所属集群名称，如果节点较多可以配置多个
  brokerClusterName = DefaultCluster
  #broker名称，master和slave使用相同的名称，表明他们的主从关系
  brokerName = broker-a
  #0表示Master，大于0表示不同的slave
  brokerId = 0
  #表示几点做消息删除动作，默认是凌晨4点
  deleteWhen = 04
  #在磁盘上保留消息的时长，单位是小时
  fileReservedTime = 48
  #有三个值：SYNC_MASTER，ASYNC_MASTER，SLAVE；同步和异步表示Master和Slave之间同步数据的机制；
  brokerRole = ASYNC_MASTER
  #刷盘策略，取值为：ASYNC_FLUSH，SYNC_FLUSH表示同步刷盘和异步刷盘；SYNC_FLUSH消息写入磁盘后才返回成功状态，ASYNC_FLUSH不需要；
  flushDiskType = ASYNC_FLUSH
  # 设置broker节点所在服务器的ip地址
  brokerIP1 = 111.119.211.126
  ```

* 启动Broker容器

  ```
  docker run -d  --name rmqbroker \
  --link rmqnamesrv:namesrv \
  --net rocketmq \
  -p 10911:10911 -p 10909:10909 \
  -v /root/rocketmq/data/broker/logs:/root/logs \
  -v /root/rocketmq/data/broker/store:/root/store \
  -v /root/rocketmq/conf/broker.conf:/opt/rocketmq-4.9.2/conf/broker.conf \
  --privileged=true \
  -e "NAMESRV_ADDR=namesrv:9876" \
  -e "MAX_POSSIBLE_HEAP=200000000" \
  apache/rocketmq:4.9.2 \
  sh mqbroker -c /opt/rocketmq-4.9.2/conf/broker.conf
  ```

  * `--link rmqnamesrv:namesrv`：将当前容器链接到名为 `rmqnamesrv` 的另一个容器，并使用别名 `namesrv`。
  * 10911端口：主要负责处理客户端与 Broker 之间的消息收发请求。
  * 10909端口：用于 Broker 高可用部署时的数据同步，确保消息的可靠性和服务的连续性。
  * `--privileged=true`：给予容器扩展权限
  * `-e "NAMESRV_ADDR=namesrv:9876"`: 设置环境变量 `NAMESRV_ADDR`，告诉 Broker Name Server 的地址，以便与之通信。
  * `-e "MAX_POSSIBLE_HEAP=200000000"`: 设置 JVM 最大可能堆内存大小为 200,000,000 字节。
  * `sh mqbroker -c /opt/rocketmq-4.9.2/conf/broker.conf`：在容器启动时执行的命令，这里是指定使用配置文件 `/opt/rocketmq-4.4.0/conf/broker.conf` 来启动 Broker。

* 验证broker是否启动成功

  ```
  docker logs rmqbroker
  ```

### 2.6.5 启动控制台

```
docker run -d --name rmqadmin \
-e "JAVA_OPTS=-Drocketmq.namesrv.addr=111.119.211.126:9876 \
-Dcom.rocketmq.sendMessageWithVIPChannel=false \
-Duser.timezone='Asia/Shanghai'" \
-v /etc/localtime:/etc/localtime \
-p 8081:8080 \
apacherocketmq/rocketmq-dashboard:1.0.0
```

* `-Dcom.rocketmq.sendMessageWithVIPChannel=false`：关闭 VIP Channel 模式。VIP Channel 是 RocketMQ 早期版本中的一种通信方式，默认监听在 Broker 的 `10912` 端口，现在基本不用了。
* `-Duser.timezone='Asia/Shanghai'"`：设置时区为中国标准时间（UTC+8）。

### 2.6.6 访问控制台

![image-20250511170033315](F:\JavaCode\MessageQueue\RocketMQ\document\image\image-20250511170033315.png)





# 三. RocketMQ快速入门

## 3.1 消息发送和监听的流程

### 3.1.1 消息生产者

1. 创建消息生产者producer，并制定生产者组名

2. 指定Nameserver地址

3. 启动producer

4. 创建消息对象，指定主题Topic、Tag和消息体等

5. 发送消息

6. 关闭生产者producer

### 3.1.2 消息消费者

1. 创建消费者consumer，制定消费者组名

2. 指定Nameserver地址

3. 创建监听订阅主题Topic和Tag等

4. 处理消息

5. 启动消费者consumer



## 3.2 搭建项目Rocketmq-demo

### 3.2.1 加入依赖

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>

<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
    <optional>true</optional>
</dependency>

<!--rocketmq原生api-->
<dependency>
    <groupId>org.apache.rocketmq</groupId>
    <artifactId>rocketmq-client</artifactId>
    <version>4.9.2</version>
</dependency>
```

### 3.2.2 编写生产者

```java
@Test
void sendMessage() throws Exception {
    // 1. 创建一个生产者 （指定一个组名：test-producer-group）
    // DefaultMQProducer producer2 = new DefaultMQProducer("test-producer-group"); 可以为一个组创建多个生产者
    DefaultMQProducer producer = new DefaultMQProducer("test-producer-group");
    // 2. 连接NameServer
    producer.setNamesrvAddr("111.119.211.126:9876");
    // 3. 启动生产者
    producer.start();
    // 4. 创建一个消息
    //    这里用的是重载的方法，指定消息主题和内容
    Message message = new Message("testTopic", "我是一个消息".getBytes());
    // 5. 发送消息
    SendResult sendResult = producer.send(message);
    System.out.println(sendResult);
    // 6. 关闭生产者
    producer.shutdown();
}
```

创建消息的消息原型：

```
// Message(String topic, String tags, String keys, int flag, byte[] body, boolean waitStoreMsgOK)
// topic：消息所属的Topic，需要提前在NameServer创建 或者在broker.conf中配置了自动创建Topic1·1· 
// tags：消息的标签，可以理解为消息的分类
// keys：消息的Key，用于消息去重
// flag：消息的标识，用于消息去重
// body：消息的内容
// waitStoreMsgOK：是否等待消息存储到NameServer
```

* 生产者为什么要设置组名？

  >没有特殊意义。同一个生产者组的生产者，可以向多个不同的主题中发送消息。



### 3.2.3 编写消费者

```java
@Test
void consumer() throws Exception{
    // 1. 创建一个消费者 (指定一个组名：test-consumer-group)
    DefaultMQPushConsumer consumer = new DefaultMQPushConsumer("test-consumer-group");
    // DefaultMQPushConsumer consumer2 = new DefaultMQPushConsumer("test-consumer-group"); // 同一个
    // 2. 连接NameServer
    consumer.setNamesrvAddr("111.119.211.126:9876");
    // 3. 订阅主题
    //    testTopic：订阅的主题名称,  *：表示订阅所有标签(所有消息)
    consumer.subscribe("testTopic", "*");
    // 4. 设置一个监听器 (异步进行的，一直监听)
    consumer.registerMessageListener(new MessageListenerConcurrently() {
        /**
         * 消费消息 这个方法会启动一个新的线程执行，
         * @param list 消息列表
         * @param context 并发消息的上下文
         * @return
         */
        @Override
        public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> list, ConsumeConcurrentlyContext context) {
            // 这个就是消费的方法
            MessageExt messageExt = list.get(0);
            System.out.println(messageExt);
            System.out.println(new String(messageExt.getBody())); // 消息内容
            System.out.println(context);
            // 返回值是ConsumeConcurrentlyStatus,是一个枚举类型
            // 该枚举类型有两个值: CONSUME_SUCCESS, RECONSUME_LATER;
            // CONSUME_SUCCESS表示成功，消息会从mq中出队
            // RECONSUME_LATER表示失败，消息会重新入队,过一会会重新投递
            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS; // 消费成功
        }
    });
    // 5. 启动消费者
    consumer.start();

    // 6.挂起当前的jvm
    System.in.read();
}
```

![image-20250511224121716](F:\JavaCode\MessageQueue\RocketMQ\document\image\image-20250511224121716.png)

* 消费者为什么要设置组名？

  > **消费者组内的消费者订阅关系必须保持一致。**即同一个消费者组的消费者只能消费同一个主题的消息。

* 假设生产者向testTopic主题中发送了一条消息，消费者组中有两个消费者c1和c2，那么这条消息到底给谁？有两种策略:

  * 轮询策略：c1和c2一人一次。
  * 广播策略：每条消息会同时发给消费者c1和c2.

* 假设有两个消费者组同时订阅了同一个主题，消息给谁？

  * 以组为单位，每组都会给一份，至于组内的策略，可以采用轮询，也可以广播。

* 负载均衡：

  ![image-20250511225915200](F:\JavaCode\MessageQueue\RocketMQ\document\image\image-20250511225915200.png)

  



